

/*
WARNING: THIS FILE IS AUTO-GENERATED. DO NOT MODIFY.

This file was generated from EnumerationSets.idl
using RTI Code Generator (rtiddsgen) version 3.1.2.
The rtiddsgen tool is part of the RTI Connext DDS distribution.
For more information, type 'rtiddsgen -help' at a command shell
or consult the Code Generator User's Manual.
*/

#include <iosfwd>
#include <iomanip>

#include "rti/topic/cdr/Serialization.hpp"

#include "EnumerationSets.hpp"
#include "EnumerationSetsPlugin.hpp"

#include <rti/util/ostream_operators.hpp>

#undef ERROR

#undef VARIABLE_PITCH

#undef DELETE

#undef PLATFORM

namespace UMAA {

    namespace Common {

        namespace MaritimeEnumeration {

            namespace AnalogSensorErrorCodeEnumType {

                std::ostream& operator << (std::ostream& o,const AnalogSensorErrorCodeEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case AnalogSensorErrorCodeEnumType::INVALID_FORMAT:
                        o << "AnalogSensorErrorCodeEnumType::INVALID_FORMAT" << " ";
                        break;
                        case AnalogSensorErrorCodeEnumType::UNKNOWN_ERROR_FAULT:
                        o << "AnalogSensorErrorCodeEnumType::UNKNOWN_ERROR_FAULT" << " ";
                        break;
                        case AnalogSensorErrorCodeEnumType::UNKNOWN_SENSOR_ID:
                        o << "AnalogSensorErrorCodeEnumType::UNKNOWN_SENSOR_ID" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace AnalogSensorErrorCodeEnumType  

            namespace AnchorActionEnumType {

                std::ostream& operator << (std::ostream& o,const AnchorActionEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case AnchorActionEnumType::LOWER:
                        o << "AnchorActionEnumType::LOWER" << " ";
                        break;
                        case AnchorActionEnumType::RAISE:
                        o << "AnchorActionEnumType::RAISE" << " ";
                        break;
                        case AnchorActionEnumType::STOP:
                        o << "AnchorActionEnumType::STOP" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace AnchorActionEnumType  

            namespace AnchorKindEnumType {

                std::ostream& operator << (std::ostream& o,const AnchorKindEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case AnchorKindEnumType::COMMERCIAL_STOCKLESS:
                        o << "AnchorKindEnumType::COMMERCIAL_STOCKLESS" << " ";
                        break;
                        case AnchorKindEnumType::DANFORTH:
                        o << "AnchorKindEnumType::DANFORTH" << " ";
                        break;
                        case AnchorKindEnumType::FOUR_FLUKE:
                        o << "AnchorKindEnumType::FOUR_FLUKE" << " ";
                        break;
                        case AnchorKindEnumType::GENERAL:
                        o << "AnchorKindEnumType::GENERAL" << " ";
                        break;
                        case AnchorKindEnumType::LIGHTWEIGHT:
                        o << "AnchorKindEnumType::LIGHTWEIGHT" << " ";
                        break;
                        case AnchorKindEnumType::MARK_2_LWT:
                        o << "AnchorKindEnumType::MARK_2_LWT" << " ";
                        break;
                        case AnchorKindEnumType::MARK_2_STOCKLESS:
                        o << "AnchorKindEnumType::MARK_2_STOCKLESS" << " ";
                        break;
                        case AnchorKindEnumType::MUSHROOM:
                        o << "AnchorKindEnumType::MUSHROOM" << " ";
                        break;
                        case AnchorKindEnumType::NAVY_TYPE_STOCK:
                        o << "AnchorKindEnumType::NAVY_TYPE_STOCK" << " ";
                        break;
                        case AnchorKindEnumType::NONMAGNETIC:
                        o << "AnchorKindEnumType::NONMAGNETIC" << " ";
                        break;
                        case AnchorKindEnumType::STANDARD_NAVY_STOCKLESS:
                        o << "AnchorKindEnumType::STANDARD_NAVY_STOCKLESS" << " ";
                        break;
                        case AnchorKindEnumType::TWO_FLUKE_BALANCED_FLUKE:
                        o << "AnchorKindEnumType::TWO_FLUKE_BALANCED_FLUKE" << " ";
                        break;
                        case AnchorKindEnumType::WEDGE_BLOCK_LWT:
                        o << "AnchorKindEnumType::WEDGE_BLOCK_LWT" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace AnchorKindEnumType  

            namespace AnchorLocationEnumType {

                std::ostream& operator << (std::ostream& o,const AnchorLocationEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case AnchorLocationEnumType::BOWER:
                        o << "AnchorLocationEnumType::BOWER" << " ";
                        break;
                        case AnchorLocationEnumType::KEEL:
                        o << "AnchorLocationEnumType::KEEL" << " ";
                        break;
                        case AnchorLocationEnumType::STERN:
                        o << "AnchorLocationEnumType::STERN" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace AnchorLocationEnumType  

            namespace AnchorStateEnumType {

                std::ostream& operator << (std::ostream& o,const AnchorStateEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case AnchorStateEnumType::DEPLOYED:
                        o << "AnchorStateEnumType::DEPLOYED" << " ";
                        break;
                        case AnchorStateEnumType::LOWERING:
                        o << "AnchorStateEnumType::LOWERING" << " ";
                        break;
                        case AnchorStateEnumType::STOPPED:
                        o << "AnchorStateEnumType::STOPPED" << " ";
                        break;
                        case AnchorStateEnumType::RAISING:
                        o << "AnchorStateEnumType::RAISING" << " ";
                        break;
                        case AnchorStateEnumType::STOWED:
                        o << "AnchorStateEnumType::STOWED" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace AnchorStateEnumType  

            namespace AudioEncodingQualityEnumType {

                std::ostream& operator << (std::ostream& o,const AudioEncodingQualityEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case AudioEncodingQualityEnumType::AVERAGE:
                        o << "AudioEncodingQualityEnumType::AVERAGE" << " ";
                        break;
                        case AudioEncodingQualityEnumType::BEST:
                        o << "AudioEncodingQualityEnumType::BEST" << " ";
                        break;
                        case AudioEncodingQualityEnumType::BETTER:
                        o << "AudioEncodingQualityEnumType::BETTER" << " ";
                        break;
                        case AudioEncodingQualityEnumType::GOOD:
                        o << "AudioEncodingQualityEnumType::GOOD" << " ";
                        break;
                        case AudioEncodingQualityEnumType::LESS:
                        o << "AudioEncodingQualityEnumType::LESS" << " ";
                        break;
                        case AudioEncodingQualityEnumType::POOR:
                        o << "AudioEncodingQualityEnumType::POOR" << " ";
                        break;
                        case AudioEncodingQualityEnumType::WORST:
                        o << "AudioEncodingQualityEnumType::WORST" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace AudioEncodingQualityEnumType  

            namespace BearingAngleEnumType {

                std::ostream& operator << (std::ostream& o,const BearingAngleEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case BearingAngleEnumType::OWNSHIP:
                        o << "BearingAngleEnumType::OWNSHIP" << " ";
                        break;
                        case BearingAngleEnumType::NORTH:
                        o << "BearingAngleEnumType::NORTH" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace BearingAngleEnumType  

            namespace BilgeControlEnumType {

                std::ostream& operator << (std::ostream& o,const BilgeControlEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case BilgeControlEnumType::AUTO:
                        o << "BilgeControlEnumType::AUTO" << " ";
                        break;
                        case BilgeControlEnumType::OFF:
                        o << "BilgeControlEnumType::OFF" << " ";
                        break;
                        case BilgeControlEnumType::ON:
                        o << "BilgeControlEnumType::ON" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace BilgeControlEnumType  

            namespace BilgeStateEnumType {

                std::ostream& operator << (std::ostream& o,const BilgeStateEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case BilgeStateEnumType::FAULT:
                        o << "BilgeStateEnumType::FAULT" << " ";
                        break;
                        case BilgeStateEnumType::OFF:
                        o << "BilgeStateEnumType::OFF" << " ";
                        break;
                        case BilgeStateEnumType::ON:
                        o << "BilgeStateEnumType::ON" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace BilgeStateEnumType  

            namespace BitDepthEnumType {

                std::ostream& operator << (std::ostream& o,const BitDepthEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case BitDepthEnumType::TEN_BITS:
                        o << "BitDepthEnumType::TEN_BITS" << " ";
                        break;
                        case BitDepthEnumType::TWELVE_BITS:
                        o << "BitDepthEnumType::TWELVE_BITS" << " ";
                        break;
                        case BitDepthEnumType::FOURTEEN_BITS:
                        o << "BitDepthEnumType::FOURTEEN_BITS" << " ";
                        break;
                        case BitDepthEnumType::SIXTEEN_BITS:
                        o << "BitDepthEnumType::SIXTEEN_BITS" << " ";
                        break;
                        case BitDepthEnumType::TWENTY_BITS:
                        o << "BitDepthEnumType::TWENTY_BITS" << " ";
                        break;
                        case BitDepthEnumType::TWENTY_FOUR_BITS:
                        o << "BitDepthEnumType::TWENTY_FOUR_BITS" << " ";
                        break;
                        case BitDepthEnumType::THIRTY_TWO_BITS:
                        o << "BitDepthEnumType::THIRTY_TWO_BITS" << " ";
                        break;
                        case BitDepthEnumType::FOURTY_BITS:
                        o << "BitDepthEnumType::FOURTY_BITS" << " ";
                        break;
                        case BitDepthEnumType::FOURTY_EIGHT_BITS:
                        o << "BitDepthEnumType::FOURTY_EIGHT_BITS" << " ";
                        break;
                        case BitDepthEnumType::FIFTY_SIX_BITS:
                        o << "BitDepthEnumType::FIFTY_SIX_BITS" << " ";
                        break;
                        case BitDepthEnumType::SIXTY_FOUR_BITS:
                        o << "BitDepthEnumType::SIXTY_FOUR_BITS" << " ";
                        break;
                        case BitDepthEnumType::EIGHT_BITS:
                        o << "BitDepthEnumType::EIGHT_BITS" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace BitDepthEnumType  

            namespace BlastConditionEnumType {

                std::ostream& operator << (std::ostream& o,const BlastConditionEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case BlastConditionEnumType::BLASTING:
                        o << "BlastConditionEnumType::BLASTING" << " ";
                        break;
                        case BlastConditionEnumType::RESTING:
                        o << "BlastConditionEnumType::RESTING" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace BlastConditionEnumType  

            namespace BlastKindEnumType {

                std::ostream& operator << (std::ostream& o,const BlastKindEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case BlastKindEnumType::LONG_BLAST:
                        o << "BlastKindEnumType::LONG_BLAST" << " ";
                        break;
                        case BlastKindEnumType::SHORT_BLAST:
                        o << "BlastKindEnumType::SHORT_BLAST" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace BlastKindEnumType  

            namespace CollisionAvoidStateEnumType {

                std::ostream& operator << (std::ostream& o,const CollisionAvoidStateEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case CollisionAvoidStateEnumType::DEVIATE_FROM_PATH:
                        o << "CollisionAvoidStateEnumType::DEVIATE_FROM_PATH" << " ";
                        break;
                        case CollisionAvoidStateEnumType::DO_NOTHING:
                        o << "CollisionAvoidStateEnumType::DO_NOTHING" << " ";
                        break;
                        case CollisionAvoidStateEnumType::STOP_ON_PATH:
                        o << "CollisionAvoidStateEnumType::STOP_ON_PATH" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace CollisionAvoidStateEnumType  

            namespace CollisionAvoidStatusEnumType {

                std::ostream& operator << (std::ostream& o,const CollisionAvoidStatusEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case CollisionAvoidStatusEnumType::ACTIVE_AVOID_OBSTACLE:
                        o << "CollisionAvoidStatusEnumType::ACTIVE_AVOID_OBSTACLE" << " ";
                        break;
                        case CollisionAvoidStatusEnumType::ACTIVE_STOP_ON_OBSTACLE:
                        o << "CollisionAvoidStatusEnumType::ACTIVE_STOP_ON_OBSTACLE" << " ";
                        break;
                        case CollisionAvoidStatusEnumType::DISABLED:
                        o << "CollisionAvoidStatusEnumType::DISABLED" << " ";
                        break;
                        case CollisionAvoidStatusEnumType::ENABLED:
                        o << "CollisionAvoidStatusEnumType::ENABLED" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace CollisionAvoidStatusEnumType  

            namespace COLREGSClassificationEnumType {

                std::ostream& operator << (std::ostream& o,const COLREGSClassificationEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case COLREGSClassificationEnumType::POWER_DRIVEN_UNDERWAY:
                        o << "COLREGSClassificationEnumType::POWER_DRIVEN_UNDERWAY" << " ";
                        break;
                        case COLREGSClassificationEnumType::SAILING:
                        o << "COLREGSClassificationEnumType::SAILING" << " ";
                        break;
                        case COLREGSClassificationEnumType::FISHING:
                        o << "COLREGSClassificationEnumType::FISHING" << " ";
                        break;
                        case COLREGSClassificationEnumType::NOT_UNDER_COMMAND:
                        o << "COLREGSClassificationEnumType::NOT_UNDER_COMMAND" << " ";
                        break;
                        case COLREGSClassificationEnumType::RESTRICTED_IN_ABILITY_TO_MANUEVER:
                        o << "COLREGSClassificationEnumType::RESTRICTED_IN_ABILITY_TO_MANUEVER" << " ";
                        break;
                        case COLREGSClassificationEnumType::ANCHORED:
                        o << "COLREGSClassificationEnumType::ANCHORED" << " ";
                        break;
                        case COLREGSClassificationEnumType::CONSTRAINED_BY_DRAUGHT:
                        o << "COLREGSClassificationEnumType::CONSTRAINED_BY_DRAUGHT" << " ";
                        break;
                        case COLREGSClassificationEnumType::PUSHING:
                        o << "COLREGSClassificationEnumType::PUSHING" << " ";
                        break;
                        case COLREGSClassificationEnumType::TOWING:
                        o << "COLREGSClassificationEnumType::TOWING" << " ";
                        break;
                        case COLREGSClassificationEnumType::NON_VESSEL:
                        o << "COLREGSClassificationEnumType::NON_VESSEL" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace COLREGSClassificationEnumType  

            namespace CommandStatusReasonEnumType {

                std::ostream& operator << (std::ostream& o,const CommandStatusReasonEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case CommandStatusReasonEnumType::CANCELED:
                        o << "CommandStatusReasonEnumType::CANCELED" << " ";
                        break;
                        case CommandStatusReasonEnumType::VALIDATION_FAILED:
                        o << "CommandStatusReasonEnumType::VALIDATION_FAILED" << " ";
                        break;
                        case CommandStatusReasonEnumType::OBJECTIVE_FAILED:
                        o << "CommandStatusReasonEnumType::OBJECTIVE_FAILED" << " ";
                        break;
                        case CommandStatusReasonEnumType::SERVICE_FAILED:
                        o << "CommandStatusReasonEnumType::SERVICE_FAILED" << " ";
                        break;
                        case CommandStatusReasonEnumType::RESOURCE_FAILED:
                        o << "CommandStatusReasonEnumType::RESOURCE_FAILED" << " ";
                        break;
                        case CommandStatusReasonEnumType::RESOURCE_REJECTED:
                        o << "CommandStatusReasonEnumType::RESOURCE_REJECTED" << " ";
                        break;
                        case CommandStatusReasonEnumType::INTERRUPTED:
                        o << "CommandStatusReasonEnumType::INTERRUPTED" << " ";
                        break;
                        case CommandStatusReasonEnumType::TIMEOUT:
                        o << "CommandStatusReasonEnumType::TIMEOUT" << " ";
                        break;
                        case CommandStatusReasonEnumType::SUCCEEDED:
                        o << "CommandStatusReasonEnumType::SUCCEEDED" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace CommandStatusReasonEnumType  

            namespace ContactManeuverInfluenceEnumType {

                std::ostream& operator << (std::ostream& o,const ContactManeuverInfluenceEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case ContactManeuverInfluenceEnumType::BEING_OVERTAKEN_COMPLIANT:
                        o << "ContactManeuverInfluenceEnumType::BEING_OVERTAKEN_COMPLIANT" << " ";
                        break;
                        case ContactManeuverInfluenceEnumType::BEING_OVERTAKEN_NONCOMPLIANT:
                        o << "ContactManeuverInfluenceEnumType::BEING_OVERTAKEN_NONCOMPLIANT" << " ";
                        break;
                        case ContactManeuverInfluenceEnumType::CROSSING_LEFT_COMPLIANT:
                        o << "ContactManeuverInfluenceEnumType::CROSSING_LEFT_COMPLIANT" << " ";
                        break;
                        case ContactManeuverInfluenceEnumType::CROSSING_LEFT_NONCOMPLIANT:
                        o << "ContactManeuverInfluenceEnumType::CROSSING_LEFT_NONCOMPLIANT" << " ";
                        break;
                        case ContactManeuverInfluenceEnumType::CROSSING_RIGHT_COMPLIANT:
                        o << "ContactManeuverInfluenceEnumType::CROSSING_RIGHT_COMPLIANT" << " ";
                        break;
                        case ContactManeuverInfluenceEnumType::CROSSING_RIGHT_NONCOMPLIANT:
                        o << "ContactManeuverInfluenceEnumType::CROSSING_RIGHT_NONCOMPLIANT" << " ";
                        break;
                        case ContactManeuverInfluenceEnumType::HEAD_ON_COMPLIANT:
                        o << "ContactManeuverInfluenceEnumType::HEAD_ON_COMPLIANT" << " ";
                        break;
                        case ContactManeuverInfluenceEnumType::HEAD_ON_NONCOMPLIANT:
                        o << "ContactManeuverInfluenceEnumType::HEAD_ON_NONCOMPLIANT" << " ";
                        break;
                        case ContactManeuverInfluenceEnumType::OVERTAKING_COMPLIANT:
                        o << "ContactManeuverInfluenceEnumType::OVERTAKING_COMPLIANT" << " ";
                        break;
                        case ContactManeuverInfluenceEnumType::OVERTAKING_NONCOMPLIANT:
                        o << "ContactManeuverInfluenceEnumType::OVERTAKING_NONCOMPLIANT" << " ";
                        break;
                        case ContactManeuverInfluenceEnumType::GUIDE:
                        o << "ContactManeuverInfluenceEnumType::GUIDE" << " ";
                        break;
                        case ContactManeuverInfluenceEnumType::IN_EXTREMIS:
                        o << "ContactManeuverInfluenceEnumType::IN_EXTREMIS" << " ";
                        break;
                        case ContactManeuverInfluenceEnumType::COLLISION_AVOIDANCE:
                        o << "ContactManeuverInfluenceEnumType::COLLISION_AVOIDANCE" << " ";
                        break;
                        case ContactManeuverInfluenceEnumType::PREEMPTIVE:
                        o << "ContactManeuverInfluenceEnumType::PREEMPTIVE" << " ";
                        break;
                        case ContactManeuverInfluenceEnumType::OBSTACLE_AVOIDANCE:
                        o << "ContactManeuverInfluenceEnumType::OBSTACLE_AVOIDANCE" << " ";
                        break;
                        case ContactManeuverInfluenceEnumType::NONE:
                        o << "ContactManeuverInfluenceEnumType::NONE" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace ContactManeuverInfluenceEnumType  

            namespace ContingencyBehaviorEnumType {

                std::ostream& operator << (std::ostream& o,const ContingencyBehaviorEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case ContingencyBehaviorEnumType::CONTINUE:
                        o << "ContingencyBehaviorEnumType::CONTINUE" << " ";
                        break;
                        case ContingencyBehaviorEnumType::FINISH:
                        o << "ContingencyBehaviorEnumType::FINISH" << " ";
                        break;
                        case ContingencyBehaviorEnumType::LOITER:
                        o << "ContingencyBehaviorEnumType::LOITER" << " ";
                        break;
                        case ContingencyBehaviorEnumType::NONE:
                        o << "ContingencyBehaviorEnumType::NONE" << " ";
                        break;
                        case ContingencyBehaviorEnumType::VEHICLE_SPECIFIC:
                        o << "ContingencyBehaviorEnumType::VEHICLE_SPECIFIC" << " ";
                        break;
                        case ContingencyBehaviorEnumType::_HOME:
                        o << "ContingencyBehaviorEnumType::_HOME" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace ContingencyBehaviorEnumType  

            namespace CoordinateSystemEnumType {

                std::ostream& operator << (std::ostream& o,const CoordinateSystemEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case CoordinateSystemEnumType::SENSOR_COORDINATE_SYSTEM:
                        o << "CoordinateSystemEnumType::SENSOR_COORDINATE_SYSTEM" << " ";
                        break;
                        case CoordinateSystemEnumType::VEHICLE_COORDINATE_SYSTEM:
                        o << "CoordinateSystemEnumType::VEHICLE_COORDINATE_SYSTEM" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace CoordinateSystemEnumType  

            namespace CoreStateEnumType {

                std::ostream& operator << (std::ostream& o,const CoreStateEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case CoreStateEnumType::EMERGENCY:
                        o << "CoreStateEnumType::EMERGENCY" << " ";
                        break;
                        case CoreStateEnumType::FAILURE:
                        o << "CoreStateEnumType::FAILURE" << " ";
                        break;
                        case CoreStateEnumType::INITIAL:
                        o << "CoreStateEnumType::INITIAL" << " ";
                        break;
                        case CoreStateEnumType::READY:
                        o << "CoreStateEnumType::READY" << " ";
                        break;
                        case CoreStateEnumType::RESET:
                        o << "CoreStateEnumType::RESET" << " ";
                        break;
                        case CoreStateEnumType::RESUME:
                        o << "CoreStateEnumType::RESUME" << " ";
                        break;
                        case CoreStateEnumType::SHUTDOWN:
                        o << "CoreStateEnumType::SHUTDOWN" << " ";
                        break;
                        case CoreStateEnumType::STANDBY:
                        o << "CoreStateEnumType::STANDBY" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace CoreStateEnumType  

            namespace DigitalAudioFormatEnumType {

                std::ostream& operator << (std::ostream& o,const DigitalAudioFormatEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case DigitalAudioFormatEnumType::AAC_MPEG2:
                        o << "DigitalAudioFormatEnumType::AAC_MPEG2" << " ";
                        break;
                        case DigitalAudioFormatEnumType::AAC_MPEG4:
                        o << "DigitalAudioFormatEnumType::AAC_MPEG4" << " ";
                        break;
                        case DigitalAudioFormatEnumType::AIFF:
                        o << "DigitalAudioFormatEnumType::AIFF" << " ";
                        break;
                        case DigitalAudioFormatEnumType::ALAC:
                        o << "DigitalAudioFormatEnumType::ALAC" << " ";
                        break;
                        case DigitalAudioFormatEnumType::DOLBY_DIGITAL:
                        o << "DigitalAudioFormatEnumType::DOLBY_DIGITAL" << " ";
                        break;
                        case DigitalAudioFormatEnumType::DTS:
                        o << "DigitalAudioFormatEnumType::DTS" << " ";
                        break;
                        case DigitalAudioFormatEnumType::FLAC:
                        o << "DigitalAudioFormatEnumType::FLAC" << " ";
                        break;
                        case DigitalAudioFormatEnumType::LPCM_PCM:
                        o << "DigitalAudioFormatEnumType::LPCM_PCM" << " ";
                        break;
                        case DigitalAudioFormatEnumType::MP2:
                        o << "DigitalAudioFormatEnumType::MP2" << " ";
                        break;
                        case DigitalAudioFormatEnumType::MP3:
                        o << "DigitalAudioFormatEnumType::MP3" << " ";
                        break;
                        case DigitalAudioFormatEnumType::REAL_AUDIO:
                        o << "DigitalAudioFormatEnumType::REAL_AUDIO" << " ";
                        break;
                        case DigitalAudioFormatEnumType::SPEEX:
                        o << "DigitalAudioFormatEnumType::SPEEX" << " ";
                        break;
                        case DigitalAudioFormatEnumType::TRUE_AUDIO:
                        o << "DigitalAudioFormatEnumType::TRUE_AUDIO" << " ";
                        break;
                        case DigitalAudioFormatEnumType::ULAW:
                        o << "DigitalAudioFormatEnumType::ULAW" << " ";
                        break;
                        case DigitalAudioFormatEnumType::VORBIS:
                        o << "DigitalAudioFormatEnumType::VORBIS" << " ";
                        break;
                        case DigitalAudioFormatEnumType::WAV:
                        o << "DigitalAudioFormatEnumType::WAV" << " ";
                        break;
                        case DigitalAudioFormatEnumType::WMA:
                        o << "DigitalAudioFormatEnumType::WMA" << " ";
                        break;
                        case DigitalAudioFormatEnumType::WMA9_LOSS_LESS:
                        o << "DigitalAudioFormatEnumType::WMA9_LOSS_LESS" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace DigitalAudioFormatEnumType  

            namespace DigitalSensorErrorCodeEnumType {

                std::ostream& operator << (std::ostream& o,const DigitalSensorErrorCodeEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case DigitalSensorErrorCodeEnumType::INVALID_FORMAT:
                        o << "DigitalSensorErrorCodeEnumType::INVALID_FORMAT" << " ";
                        break;
                        case DigitalSensorErrorCodeEnumType::INVALID_FRAME_SIZE:
                        o << "DigitalSensorErrorCodeEnumType::INVALID_FRAME_SIZE" << " ";
                        break;
                        case DigitalSensorErrorCodeEnumType::INVALID_MAX_BIT_RATE:
                        o << "DigitalSensorErrorCodeEnumType::INVALID_MAX_BIT_RATE" << " ";
                        break;
                        case DigitalSensorErrorCodeEnumType::INVALID_MAX_FRAME_RATE:
                        o << "DigitalSensorErrorCodeEnumType::INVALID_MAX_FRAME_RATE" << " ";
                        break;
                        case DigitalSensorErrorCodeEnumType::INVALID_MIN_BIT_RATE:
                        o << "DigitalSensorErrorCodeEnumType::INVALID_MIN_BIT_RATE" << " ";
                        break;
                        case DigitalSensorErrorCodeEnumType::INVALID_MIN_FRAME_RATE:
                        o << "DigitalSensorErrorCodeEnumType::INVALID_MIN_FRAME_RATE" << " ";
                        break;
                        case DigitalSensorErrorCodeEnumType::MULTIPLE_INVALID_PARAMETERS:
                        o << "DigitalSensorErrorCodeEnumType::MULTIPLE_INVALID_PARAMETERS" << " ";
                        break;
                        case DigitalSensorErrorCodeEnumType::UNKNOWN_ERROR_FAULT:
                        o << "DigitalSensorErrorCodeEnumType::UNKNOWN_ERROR_FAULT" << " ";
                        break;
                        case DigitalSensorErrorCodeEnumType::UNKNOWN_SENSOR_ID:
                        o << "DigitalSensorErrorCodeEnumType::UNKNOWN_SENSOR_ID" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace DigitalSensorErrorCodeEnumType  

            namespace DomainEnumType {

                std::ostream& operator << (std::ostream& o,const DomainEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case DomainEnumType::AIR:
                        o << "DomainEnumType::AIR" << " ";
                        break;
                        case DomainEnumType::GROUND:
                        o << "DomainEnumType::GROUND" << " ";
                        break;
                        case DomainEnumType::SURFACE:
                        o << "DomainEnumType::SURFACE" << " ";
                        break;
                        case DomainEnumType::UNDERSEA:
                        o << "DomainEnumType::UNDERSEA" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace DomainEnumType  

            namespace EngineKindEnumType {

                std::ostream& operator << (std::ostream& o,const EngineKindEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case EngineKindEnumType::DIESEL:
                        o << "EngineKindEnumType::DIESEL" << " ";
                        break;
                        case EngineKindEnumType::GAS:
                        o << "EngineKindEnumType::GAS" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace EngineKindEnumType  

            namespace ErrorCodeEnumType {

                std::ostream& operator << (std::ostream& o,const ErrorCodeEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case ErrorCodeEnumType::ACTUATOR:
                        o << "ErrorCodeEnumType::ACTUATOR" << " ";
                        break;
                        case ErrorCodeEnumType::FILESYS:
                        o << "ErrorCodeEnumType::FILESYS" << " ";
                        break;
                        case ErrorCodeEnumType::NONE:
                        o << "ErrorCodeEnumType::NONE" << " ";
                        break;
                        case ErrorCodeEnumType::POWER:
                        o << "ErrorCodeEnumType::POWER" << " ";
                        break;
                        case ErrorCodeEnumType::PROCESSOR:
                        o << "ErrorCodeEnumType::PROCESSOR" << " ";
                        break;
                        case ErrorCodeEnumType::RAM:
                        o << "ErrorCodeEnumType::RAM" << " ";
                        break;
                        case ErrorCodeEnumType::ROM:
                        o << "ErrorCodeEnumType::ROM" << " ";
                        break;
                        case ErrorCodeEnumType::SENSOR:
                        o << "ErrorCodeEnumType::SENSOR" << " ";
                        break;
                        case ErrorCodeEnumType::SOFTWARE:
                        o << "ErrorCodeEnumType::SOFTWARE" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace ErrorCodeEnumType  

            namespace ErrorConditionEnumType {

                std::ostream& operator << (std::ostream& o,const ErrorConditionEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case ErrorConditionEnumType::INFO:
                        o << "ErrorConditionEnumType::INFO" << " ";
                        break;
                        case ErrorConditionEnumType::WARN:
                        o << "ErrorConditionEnumType::WARN" << " ";
                        break;
                        case ErrorConditionEnumType::ERROR:
                        o << "ErrorConditionEnumType::ERROR" << " ";
                        break;
                        case ErrorConditionEnumType::FAIL:
                        o << "ErrorConditionEnumType::FAIL" << " ";
                        break;
                        case ErrorConditionEnumType::NONE:
                        o << "ErrorConditionEnumType::NONE" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace ErrorConditionEnumType  

            namespace ExposureModeEnumType {

                std::ostream& operator << (std::ostream& o,const ExposureModeEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case ExposureModeEnumType::AUTO_DEFAULT:
                        o << "ExposureModeEnumType::AUTO_DEFAULT" << " ";
                        break;
                        case ExposureModeEnumType::MANUAL:
                        o << "ExposureModeEnumType::MANUAL" << " ";
                        break;
                        case ExposureModeEnumType::APETURE_PRIORITY:
                        o << "ExposureModeEnumType::APETURE_PRIORITY" << " ";
                        break;
                        case ExposureModeEnumType::SHUTTER_PRIORITY:
                        o << "ExposureModeEnumType::SHUTTER_PRIORITY" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace ExposureModeEnumType  

            namespace FrameSizeEnumType {

                std::ostream& operator << (std::ostream& o,const FrameSizeEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case FrameSizeEnumType::CGA_320x200:
                        o << "FrameSizeEnumType::CGA_320x200" << " ";
                        break;
                        case FrameSizeEnumType::CIF_1408x1152:
                        o << "FrameSizeEnumType::CIF_1408x1152" << " ";
                        break;
                        case FrameSizeEnumType::CIF_352x288:
                        o << "FrameSizeEnumType::CIF_352x288" << " ";
                        break;
                        case FrameSizeEnumType::CIF_704x576:
                        o << "FrameSizeEnumType::CIF_704x576" << " ";
                        break;
                        case FrameSizeEnumType::EGA_640x350:
                        o << "FrameSizeEnumType::EGA_640x350" << " ";
                        break;
                        case FrameSizeEnumType::HD1080_1920x1080:
                        o << "FrameSizeEnumType::HD1080_1920x1080" << " ";
                        break;
                        case FrameSizeEnumType::HD480_852x480:
                        o << "FrameSizeEnumType::HD480_852x480" << " ";
                        break;
                        case FrameSizeEnumType::HD720_1280x720:
                        o << "FrameSizeEnumType::HD720_1280x720" << " ";
                        break;
                        case FrameSizeEnumType::HSXGA_5120x4096:
                        o << "FrameSizeEnumType::HSXGA_5120x4096" << " ";
                        break;
                        case FrameSizeEnumType::QCIF_176x144:
                        o << "FrameSizeEnumType::QCIF_176x144" << " ";
                        break;
                        case FrameSizeEnumType::QQVGA_160x120:
                        o << "FrameSizeEnumType::QQVGA_160x120" << " ";
                        break;
                        case FrameSizeEnumType::QSXGA_2560x2048:
                        o << "FrameSizeEnumType::QSXGA_2560x2048" << " ";
                        break;
                        case FrameSizeEnumType::QVGA_320x240:
                        o << "FrameSizeEnumType::QVGA_320x240" << " ";
                        break;
                        case FrameSizeEnumType::QXGA_2048x1536:
                        o << "FrameSizeEnumType::QXGA_2048x1536" << " ";
                        break;
                        case FrameSizeEnumType::SQCIF_128x96:
                        o << "FrameSizeEnumType::SQCIF_128x96" << " ";
                        break;
                        case FrameSizeEnumType::SVGA_800x600:
                        o << "FrameSizeEnumType::SVGA_800x600" << " ";
                        break;
                        case FrameSizeEnumType::SXGA_1280x1024:
                        o << "FrameSizeEnumType::SXGA_1280x1024" << " ";
                        break;
                        case FrameSizeEnumType::UXGA_1600x1200:
                        o << "FrameSizeEnumType::UXGA_1600x1200" << " ";
                        break;
                        case FrameSizeEnumType::VGA_640x480:
                        o << "FrameSizeEnumType::VGA_640x480" << " ";
                        break;
                        case FrameSizeEnumType::WHSXGA_6400x4096:
                        o << "FrameSizeEnumType::WHSXGA_6400x4096" << " ";
                        break;
                        case FrameSizeEnumType::WHUXGA_7680x4800:
                        o << "FrameSizeEnumType::WHUXGA_7680x4800" << " ";
                        break;
                        case FrameSizeEnumType::WOXGA_2560x1600:
                        o << "FrameSizeEnumType::WOXGA_2560x1600" << " ";
                        break;
                        case FrameSizeEnumType::WQSXGA_3200x2048:
                        o << "FrameSizeEnumType::WQSXGA_3200x2048" << " ";
                        break;
                        case FrameSizeEnumType::WQUXGA_3840x2400:
                        o << "FrameSizeEnumType::WQUXGA_3840x2400" << " ";
                        break;
                        case FrameSizeEnumType::WSXGA_1600x1024:
                        o << "FrameSizeEnumType::WSXGA_1600x1024" << " ";
                        break;
                        case FrameSizeEnumType::WUXGA_1920x1200:
                        o << "FrameSizeEnumType::WUXGA_1920x1200" << " ";
                        break;
                        case FrameSizeEnumType::WVGA_852x480:
                        o << "FrameSizeEnumType::WVGA_852x480" << " ";
                        break;
                        case FrameSizeEnumType::WXGA_1366x768:
                        o << "FrameSizeEnumType::WXGA_1366x768" << " ";
                        break;
                        case FrameSizeEnumType::XGA_1024x768:
                        o << "FrameSizeEnumType::XGA_1024x768" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace FrameSizeEnumType  

            namespace GPSConstellationEnumType {

                std::ostream& operator << (std::ostream& o,const GPSConstellationEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case GPSConstellationEnumType::UNKNOWN:
                        o << "GPSConstellationEnumType::UNKNOWN" << " ";
                        break;
                        case GPSConstellationEnumType::BEIDOU:
                        o << "GPSConstellationEnumType::BEIDOU" << " ";
                        break;
                        case GPSConstellationEnumType::GALILEO:
                        o << "GPSConstellationEnumType::GALILEO" << " ";
                        break;
                        case GPSConstellationEnumType::GLONASS:
                        o << "GPSConstellationEnumType::GLONASS" << " ";
                        break;
                        case GPSConstellationEnumType::GPS:
                        o << "GPSConstellationEnumType::GPS" << " ";
                        break;
                        case GPSConstellationEnumType::IRNSS:
                        o << "GPSConstellationEnumType::IRNSS" << " ";
                        break;
                        case GPSConstellationEnumType::QZSS:
                        o << "GPSConstellationEnumType::QZSS" << " ";
                        break;
                        case GPSConstellationEnumType::SBAS:
                        o << "GPSConstellationEnumType::SBAS" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace GPSConstellationEnumType  

            namespace GPSFixEnumType {

                std::ostream& operator << (std::ostream& o,const GPSFixEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case GPSFixEnumType::INITIATING:
                        o << "GPSFixEnumType::INITIATING" << " ";
                        break;
                        case GPSFixEnumType::PERFORMING:
                        o << "GPSFixEnumType::PERFORMING" << " ";
                        break;
                        case GPSFixEnumType::STABLE:
                        o << "GPSFixEnumType::STABLE" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace GPSFixEnumType  

            namespace GPSNavigationSolutionEnumType {

                std::ostream& operator << (std::ostream& o,const GPSNavigationSolutionEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case GPSNavigationSolutionEnumType::GPS_1:
                        o << "GPSNavigationSolutionEnumType::GPS_1" << " ";
                        break;
                        case GPSNavigationSolutionEnumType::GPS_2:
                        o << "GPSNavigationSolutionEnumType::GPS_2" << " ";
                        break;
                        case GPSNavigationSolutionEnumType::GPS_2D:
                        o << "GPSNavigationSolutionEnumType::GPS_2D" << " ";
                        break;
                        case GPSNavigationSolutionEnumType::GPS_3:
                        o << "GPSNavigationSolutionEnumType::GPS_3" << " ";
                        break;
                        case GPSNavigationSolutionEnumType::GPS_3D:
                        o << "GPSNavigationSolutionEnumType::GPS_3D" << " ";
                        break;
                        case GPSNavigationSolutionEnumType::GPS_4:
                        o << "GPSNavigationSolutionEnumType::GPS_4" << " ";
                        break;
                        case GPSNavigationSolutionEnumType::GPS_DEAD_RECK:
                        o << "GPSNavigationSolutionEnumType::GPS_DEAD_RECK" << " ";
                        break;
                        case GPSNavigationSolutionEnumType::NO_NAV:
                        o << "GPSNavigationSolutionEnumType::NO_NAV" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace GPSNavigationSolutionEnumType  

            namespace GuardedTeleoperationStatusEnumType {

                std::ostream& operator << (std::ostream& o,const GuardedTeleoperationStatusEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case GuardedTeleoperationStatusEnumType::DISABLED:
                        o << "GuardedTeleoperationStatusEnumType::DISABLED" << " ";
                        break;
                        case GuardedTeleoperationStatusEnumType::ENABLED:
                        o << "GuardedTeleoperationStatusEnumType::ENABLED" << " ";
                        break;
                        case GuardedTeleoperationStatusEnumType::ACTIVE_AVOID_OBSTACLE:
                        o << "GuardedTeleoperationStatusEnumType::ACTIVE_AVOID_OBSTACLE" << " ";
                        break;
                        case GuardedTeleoperationStatusEnumType::PITCHOVER_LIMIT:
                        o << "GuardedTeleoperationStatusEnumType::PITCHOVER_LIMIT" << " ";
                        break;
                        case GuardedTeleoperationStatusEnumType::ROLLOVER_LIMIT:
                        o << "GuardedTeleoperationStatusEnumType::ROLLOVER_LIMIT" << " ";
                        break;
                        case GuardedTeleoperationStatusEnumType::ACTIVE_STOP_ON_OBSTACLE:
                        o << "GuardedTeleoperationStatusEnumType::ACTIVE_STOP_ON_OBSTACLE" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace GuardedTeleoperationStatusEnumType  

            namespace H264EncodingEnumType {

                std::ostream& operator << (std::ostream& o,const H264EncodingEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case H264EncodingEnumType::BASELINE:
                        o << "H264EncodingEnumType::BASELINE" << " ";
                        break;
                        case H264EncodingEnumType::CAVLC444:
                        o << "H264EncodingEnumType::CAVLC444" << " ";
                        break;
                        case H264EncodingEnumType::CONSTRAINED_BASELINE:
                        o << "H264EncodingEnumType::CONSTRAINED_BASELINE" << " ";
                        break;
                        case H264EncodingEnumType::CONSTRAINED_HIGH:
                        o << "H264EncodingEnumType::CONSTRAINED_HIGH" << " ";
                        break;
                        case H264EncodingEnumType::EXTENDED:
                        o << "H264EncodingEnumType::EXTENDED" << " ";
                        break;
                        case H264EncodingEnumType::HIGH:
                        o << "H264EncodingEnumType::HIGH" << " ";
                        break;
                        case H264EncodingEnumType::HIGH10:
                        o << "H264EncodingEnumType::HIGH10" << " ";
                        break;
                        case H264EncodingEnumType::HIGH10_INTRA:
                        o << "H264EncodingEnumType::HIGH10_INTRA" << " ";
                        break;
                        case H264EncodingEnumType::HIGH422:
                        o << "H264EncodingEnumType::HIGH422" << " ";
                        break;
                        case H264EncodingEnumType::HIGH422_INTRA:
                        o << "H264EncodingEnumType::HIGH422_INTRA" << " ";
                        break;
                        case H264EncodingEnumType::HIGH444_INTRA:
                        o << "H264EncodingEnumType::HIGH444_INTRA" << " ";
                        break;
                        case H264EncodingEnumType::HIGH444_PREDICTIVE:
                        o << "H264EncodingEnumType::HIGH444_PREDICTIVE" << " ";
                        break;
                        case H264EncodingEnumType::MAIN:
                        o << "H264EncodingEnumType::MAIN" << " ";
                        break;
                        case H264EncodingEnumType::MULTIVIEW_HIGH:
                        o << "H264EncodingEnumType::MULTIVIEW_HIGH" << " ";
                        break;
                        case H264EncodingEnumType::PROGRESSIVE_HIGH:
                        o << "H264EncodingEnumType::PROGRESSIVE_HIGH" << " ";
                        break;
                        case H264EncodingEnumType::SCALABLE_BASELINE:
                        o << "H264EncodingEnumType::SCALABLE_BASELINE" << " ";
                        break;
                        case H264EncodingEnumType::SCALABLE_CONSTRAINED_BASELINE:
                        o << "H264EncodingEnumType::SCALABLE_CONSTRAINED_BASELINE" << " ";
                        break;
                        case H264EncodingEnumType::SCALABLE_CONSTRAINED_HIGH:
                        o << "H264EncodingEnumType::SCALABLE_CONSTRAINED_HIGH" << " ";
                        break;
                        case H264EncodingEnumType::SCALABLE_HIGH:
                        o << "H264EncodingEnumType::SCALABLE_HIGH" << " ";
                        break;
                        case H264EncodingEnumType::SCALABLE_HIGH_INTRA:
                        o << "H264EncodingEnumType::SCALABLE_HIGH_INTRA" << " ";
                        break;
                        case H264EncodingEnumType::STEREO_HIGH:
                        o << "H264EncodingEnumType::STEREO_HIGH" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace H264EncodingEnumType  

            namespace H264PresetEnumType {

                std::ostream& operator << (std::ostream& o,const H264PresetEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case H264PresetEnumType::BEST_QUALITY:
                        o << "H264PresetEnumType::BEST_QUALITY" << " ";
                        break;
                        case H264PresetEnumType::DRIVE_VISION:
                        o << "H264PresetEnumType::DRIVE_VISION" << " ";
                        break;
                        case H264PresetEnumType::LOW_LATENCY:
                        o << "H264PresetEnumType::LOW_LATENCY" << " ";
                        break;
                        case H264PresetEnumType::MANIPULATION:
                        o << "H264PresetEnumType::MANIPULATION" << " ";
                        break;
                        case H264PresetEnumType::PERSISTENT_STARE:
                        o << "H264PresetEnumType::PERSISTENT_STARE" << " ";
                        break;
                        case H264PresetEnumType::PROGRAM_SPECIFIC_1:
                        o << "H264PresetEnumType::PROGRAM_SPECIFIC_1" << " ";
                        break;
                        case H264PresetEnumType::PROGRAM_SPECIFIC_2:
                        o << "H264PresetEnumType::PROGRAM_SPECIFIC_2" << " ";
                        break;
                        case H264PresetEnumType::PROGRAM_SPECIFIC_3:
                        o << "H264PresetEnumType::PROGRAM_SPECIFIC_3" << " ";
                        break;
                        case H264PresetEnumType::PROGRAM_SPECIFIC_4:
                        o << "H264PresetEnumType::PROGRAM_SPECIFIC_4" << " ";
                        break;
                        case H264PresetEnumType::SLOW_COMMS:
                        o << "H264PresetEnumType::SLOW_COMMS" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace H264PresetEnumType  

            namespace HandoverResultEnumType {

                std::ostream& operator << (std::ostream& o,const HandoverResultEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case HandoverResultEnumType::DEFERRED:
                        o << "HandoverResultEnumType::DEFERRED" << " ";
                        break;
                        case HandoverResultEnumType::DENIED:
                        o << "HandoverResultEnumType::DENIED" << " ";
                        break;
                        case HandoverResultEnumType::GRANTED:
                        o << "HandoverResultEnumType::GRANTED" << " ";
                        break;
                        case HandoverResultEnumType::TIMEOUT:
                        o << "HandoverResultEnumType::TIMEOUT" << " ";
                        break;
                        case HandoverResultEnumType::INSUFFICIENT_AUTHORITY:
                        o << "HandoverResultEnumType::INSUFFICIENT_AUTHORITY" << " ";
                        break;
                        case HandoverResultEnumType::NOT_AVAILABLE:
                        o << "HandoverResultEnumType::NOT_AVAILABLE" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace HandoverResultEnumType  

            namespace HeadingReferenceEnumType {

                std::ostream& operator << (std::ostream& o,const HeadingReferenceEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case HeadingReferenceEnumType::MAGNETIC_NORTH:
                        o << "HeadingReferenceEnumType::MAGNETIC_NORTH" << " ";
                        break;
                        case HeadingReferenceEnumType::TRUE_NORTH:
                        o << "HeadingReferenceEnumType::TRUE_NORTH" << " ";
                        break;
                        case HeadingReferenceEnumType::WIND_DIRECTION:
                        o << "HeadingReferenceEnumType::WIND_DIRECTION" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace HeadingReferenceEnumType  

            namespace HeightModeEnumType {

                std::ostream& operator << (std::ostream& o,const HeightModeEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case HeightModeEnumType::ALTITUDE:
                        o << "HeightModeEnumType::ALTITUDE" << " ";
                        break;
                        case HeightModeEnumType::DEPTH:
                        o << "HeightModeEnumType::DEPTH" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace HeightModeEnumType  

            namespace HoverKindEnumType {

                std::ostream& operator << (std::ostream& o,const HoverKindEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case HoverKindEnumType::LAT_LON_PRIORITY:
                        o << "HoverKindEnumType::LAT_LON_PRIORITY" << " ";
                        break;
                        case HoverKindEnumType::Z_PRIORITY:
                        o << "HoverKindEnumType::Z_PRIORITY" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace HoverKindEnumType  

            namespace IgnitionStateEnumType {

                std::ostream& operator << (std::ostream& o,const IgnitionStateEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case IgnitionStateEnumType::OFF:
                        o << "IgnitionStateEnumType::OFF" << " ";
                        break;
                        case IgnitionStateEnumType::RUN:
                        o << "IgnitionStateEnumType::RUN" << " ";
                        break;
                        case IgnitionStateEnumType::START:
                        o << "IgnitionStateEnumType::START" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace IgnitionStateEnumType  

            namespace ImageFormatEnumType {

                std::ostream& operator << (std::ostream& o,const ImageFormatEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case ImageFormatEnumType::BMP:
                        o << "ImageFormatEnumType::BMP" << " ";
                        break;
                        case ImageFormatEnumType::CR2_RAW:
                        o << "ImageFormatEnumType::CR2_RAW" << " ";
                        break;
                        case ImageFormatEnumType::DNG:
                        o << "ImageFormatEnumType::DNG" << " ";
                        break;
                        case ImageFormatEnumType::GIF:
                        o << "ImageFormatEnumType::GIF" << " ";
                        break;
                        case ImageFormatEnumType::JPEG:
                        o << "ImageFormatEnumType::JPEG" << " ";
                        break;
                        case ImageFormatEnumType::NEF:
                        o << "ImageFormatEnumType::NEF" << " ";
                        break;
                        case ImageFormatEnumType::PGM:
                        o << "ImageFormatEnumType::PGM" << " ";
                        break;
                        case ImageFormatEnumType::PNG:
                        o << "ImageFormatEnumType::PNG" << " ";
                        break;
                        case ImageFormatEnumType::PNM:
                        o << "ImageFormatEnumType::PNM" << " ";
                        break;
                        case ImageFormatEnumType::PPM:
                        o << "ImageFormatEnumType::PPM" << " ";
                        break;
                        case ImageFormatEnumType::TIFF:
                        o << "ImageFormatEnumType::TIFF" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace ImageFormatEnumType  

            namespace ImagingModeEnumType {

                std::ostream& operator << (std::ostream& o,const ImagingModeEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case ImagingModeEnumType::COLOR:
                        o << "ImagingModeEnumType::COLOR" << " ";
                        break;
                        case ImagingModeEnumType::GREYSCALE:
                        o << "ImagingModeEnumType::GREYSCALE" << " ";
                        break;
                        case ImagingModeEnumType::INFRARED:
                        o << "ImagingModeEnumType::INFRARED" << " ";
                        break;
                        case ImagingModeEnumType::LOWLIGHT:
                        o << "ImagingModeEnumType::LOWLIGHT" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace ImagingModeEnumType  

            namespace InertialSensorOpStatusEnumType {

                std::ostream& operator << (std::ostream& o,const InertialSensorOpStatusEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case InertialSensorOpStatusEnumType::COURSE_GPS_ALIGNMENT:
                        o << "InertialSensorOpStatusEnumType::COURSE_GPS_ALIGNMENT" << " ";
                        break;
                        case InertialSensorOpStatusEnumType::COURSE_STATIONARY_ALIGNMENT:
                        o << "InertialSensorOpStatusEnumType::COURSE_STATIONARY_ALIGNMENT" << " ";
                        break;
                        case InertialSensorOpStatusEnumType::FINE_GPS_ALIGNMENT_COMPLETE:
                        o << "InertialSensorOpStatusEnumType::FINE_GPS_ALIGNMENT_COMPLETE" << " ";
                        break;
                        case InertialSensorOpStatusEnumType::FINE_GPS_ALIGNMENT_STARTED:
                        o << "InertialSensorOpStatusEnumType::FINE_GPS_ALIGNMENT_STARTED" << " ";
                        break;
                        case InertialSensorOpStatusEnumType::FINE_STATIONARY_ALIGNMENT_COMPLETE:
                        o << "InertialSensorOpStatusEnumType::FINE_STATIONARY_ALIGNMENT_COMPLETE" << " ";
                        break;
                        case InertialSensorOpStatusEnumType::FINE_STATIONARY_ALIGNMENT_STARTED:
                        o << "InertialSensorOpStatusEnumType::FINE_STATIONARY_ALIGNMENT_STARTED" << " ";
                        break;
                        case InertialSensorOpStatusEnumType::INERTIAL_SENSOR_FAILURE:
                        o << "InertialSensorOpStatusEnumType::INERTIAL_SENSOR_FAILURE" << " ";
                        break;
                        case InertialSensorOpStatusEnumType::INIT:
                        o << "InertialSensorOpStatusEnumType::INIT" << " ";
                        break;
                        case InertialSensorOpStatusEnumType::OPERATIONAL:
                        o << "InertialSensorOpStatusEnumType::OPERATIONAL" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace InertialSensorOpStatusEnumType  

            namespace InertialSensorStateEnumType {

                std::ostream& operator << (std::ostream& o,const InertialSensorStateEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case InertialSensorStateEnumType::OFF:
                        o << "InertialSensorStateEnumType::OFF" << " ";
                        break;
                        case InertialSensorStateEnumType::ON:
                        o << "InertialSensorStateEnumType::ON" << " ";
                        break;
                        case InertialSensorStateEnumType::RESTARTING:
                        o << "InertialSensorStateEnumType::RESTARTING" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace InertialSensorStateEnumType  

            namespace LightSensitivityEnumType {

                std::ostream& operator << (std::ostream& o,const LightSensitivityEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case LightSensitivityEnumType::AUTO_DEFAULT:
                        o << "LightSensitivityEnumType::AUTO_DEFAULT" << " ";
                        break;
                        case LightSensitivityEnumType::ISO_100:
                        o << "LightSensitivityEnumType::ISO_100" << " ";
                        break;
                        case LightSensitivityEnumType::ISO_1600:
                        o << "LightSensitivityEnumType::ISO_1600" << " ";
                        break;
                        case LightSensitivityEnumType::ISO_200:
                        o << "LightSensitivityEnumType::ISO_200" << " ";
                        break;
                        case LightSensitivityEnumType::ISO_3200:
                        o << "LightSensitivityEnumType::ISO_3200" << " ";
                        break;
                        case LightSensitivityEnumType::ISO_400:
                        o << "LightSensitivityEnumType::ISO_400" << " ";
                        break;
                        case LightSensitivityEnumType::ISO_800:
                        o << "LightSensitivityEnumType::ISO_800" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace LightSensitivityEnumType  

            namespace LostCommsStatusEnumType {

                std::ostream& operator << (std::ostream& o,const LostCommsStatusEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case LostCommsStatusEnumType::ACTIVE:
                        o << "LostCommsStatusEnumType::ACTIVE" << " ";
                        break;
                        case LostCommsStatusEnumType::DISABLED:
                        o << "LostCommsStatusEnumType::DISABLED" << " ";
                        break;
                        case LostCommsStatusEnumType::ENABLED:
                        o << "LostCommsStatusEnumType::ENABLED" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace LostCommsStatusEnumType  

            namespace MastActionEnumType {

                std::ostream& operator << (std::ostream& o,const MastActionEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case MastActionEnumType::LOWER:
                        o << "MastActionEnumType::LOWER" << " ";
                        break;
                        case MastActionEnumType::RAISE:
                        o << "MastActionEnumType::RAISE" << " ";
                        break;
                        case MastActionEnumType::STOP:
                        o << "MastActionEnumType::STOP" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace MastActionEnumType  

            namespace MastStateEnumType {

                std::ostream& operator << (std::ostream& o,const MastStateEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case MastStateEnumType::DOWN:
                        o << "MastStateEnumType::DOWN" << " ";
                        break;
                        case MastStateEnumType::MOVING_DOWN:
                        o << "MastStateEnumType::MOVING_DOWN" << " ";
                        break;
                        case MastStateEnumType::MOVING_UP:
                        o << "MastStateEnumType::MOVING_UP" << " ";
                        break;
                        case MastStateEnumType::UP:
                        o << "MastStateEnumType::UP" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace MastStateEnumType  

            namespace CommandStatusEnumType {

                std::ostream& operator << (std::ostream& o,const CommandStatusEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case CommandStatusEnumType::FAILED:
                        o << "CommandStatusEnumType::FAILED" << " ";
                        break;
                        case CommandStatusEnumType::COMPLETED:
                        o << "CommandStatusEnumType::COMPLETED" << " ";
                        break;
                        case CommandStatusEnumType::ISSUED:
                        o << "CommandStatusEnumType::ISSUED" << " ";
                        break;
                        case CommandStatusEnumType::COMMANDED:
                        o << "CommandStatusEnumType::COMMANDED" << " ";
                        break;
                        case CommandStatusEnumType::EXECUTING:
                        o << "CommandStatusEnumType::EXECUTING" << " ";
                        break;
                        case CommandStatusEnumType::CANCELED:
                        o << "CommandStatusEnumType::CANCELED" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace CommandStatusEnumType  

            namespace DataEncodingEnumType {

                std::ostream& operator << (std::ostream& o,const DataEncodingEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case DataEncodingEnumType::AVI:
                        o << "DataEncodingEnumType::AVI" << " ";
                        break;
                        case DataEncodingEnumType::H_261:
                        o << "DataEncodingEnumType::H_261" << " ";
                        break;
                        case DataEncodingEnumType::H_262:
                        o << "DataEncodingEnumType::H_262" << " ";
                        break;
                        case DataEncodingEnumType::H_263:
                        o << "DataEncodingEnumType::H_263" << " ";
                        break;
                        case DataEncodingEnumType::H_263PLUS:
                        o << "DataEncodingEnumType::H_263PLUS" << " ";
                        break;
                        case DataEncodingEnumType::H_264:
                        o << "DataEncodingEnumType::H_264" << " ";
                        break;
                        case DataEncodingEnumType::MJPEG:
                        o << "DataEncodingEnumType::MJPEG" << " ";
                        break;
                        case DataEncodingEnumType::MPEG_1:
                        o << "DataEncodingEnumType::MPEG_1" << " ";
                        break;
                        case DataEncodingEnumType::MPEG_2:
                        o << "DataEncodingEnumType::MPEG_2" << " ";
                        break;
                        case DataEncodingEnumType::MPEG_4:
                        o << "DataEncodingEnumType::MPEG_4" << " ";
                        break;
                        case DataEncodingEnumType::NONE:
                        o << "DataEncodingEnumType::NONE" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace DataEncodingEnumType  

            namespace FeatureKindEnumType {

                std::ostream& operator << (std::ostream& o,const FeatureKindEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case FeatureKindEnumType::CONTACT:
                        o << "FeatureKindEnumType::CONTACT" << " ";
                        break;
                        case FeatureKindEnumType::OTHER:
                        o << "FeatureKindEnumType::OTHER" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace FeatureKindEnumType  

            namespace LoiterKindEnumType {

                std::ostream& operator << (std::ostream& o,const LoiterKindEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case LoiterKindEnumType::CIRCLE:
                        o << "LoiterKindEnumType::CIRCLE" << " ";
                        break;
                        case LoiterKindEnumType::RACETRACK:
                        o << "LoiterKindEnumType::RACETRACK" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace LoiterKindEnumType  

            namespace TaskStateEnumType {

                std::ostream& operator << (std::ostream& o,const TaskStateEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case TaskStateEnumType::PLANNED_PENDING_APPROVAL:
                        o << "TaskStateEnumType::PLANNED_PENDING_APPROVAL" << " ";
                        break;
                        case TaskStateEnumType::AWAITING_EXECUTION_APPROVAL:
                        o << "TaskStateEnumType::AWAITING_EXECUTION_APPROVAL" << " ";
                        break;
                        case TaskStateEnumType::ALLOCATED:
                        o << "TaskStateEnumType::ALLOCATED" << " ";
                        break;
                        case TaskStateEnumType::EXECUTION_APPROVED:
                        o << "TaskStateEnumType::EXECUTION_APPROVED" << " ";
                        break;
                        case TaskStateEnumType::CANCELED:
                        o << "TaskStateEnumType::CANCELED" << " ";
                        break;
                        case TaskStateEnumType::COMPLETED:
                        o << "TaskStateEnumType::COMPLETED" << " ";
                        break;
                        case TaskStateEnumType::DROPPED:
                        o << "TaskStateEnumType::DROPPED" << " ";
                        break;
                        case TaskStateEnumType::PLANNED:
                        o << "TaskStateEnumType::PLANNED" << " ";
                        break;
                        case TaskStateEnumType::PROPOSED:
                        o << "TaskStateEnumType::PROPOSED" << " ";
                        break;
                        case TaskStateEnumType::QUEUED:
                        o << "TaskStateEnumType::QUEUED" << " ";
                        break;
                        case TaskStateEnumType::EXECUTING:
                        o << "TaskStateEnumType::EXECUTING" << " ";
                        break;
                        case TaskStateEnumType::FAILED:
                        o << "TaskStateEnumType::FAILED" << " ";
                        break;
                        case TaskStateEnumType::UNALLOCATED:
                        o << "TaskStateEnumType::UNALLOCATED" << " ";
                        break;
                        case TaskStateEnumType::ALLOCATED_PENDING_APPROVAL:
                        o << "TaskStateEnumType::ALLOCATED_PENDING_APPROVAL" << " ";
                        break;
                        case TaskStateEnumType::AWAITING_MISSION_PLAN:
                        o << "TaskStateEnumType::AWAITING_MISSION_PLAN" << " ";
                        break;
                        case TaskStateEnumType::PAUSED:
                        o << "TaskStateEnumType::PAUSED" << " ";
                        break;
                        case TaskStateEnumType::QUEUING:
                        o << "TaskStateEnumType::QUEUING" << " ";
                        break;
                        case TaskStateEnumType::PLANNING:
                        o << "TaskStateEnumType::PLANNING" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace TaskStateEnumType  

            namespace TransportEncodingEnumType {

                std::ostream& operator << (std::ostream& o,const TransportEncodingEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case TransportEncodingEnumType::MPEG_2:
                        o << "TransportEncodingEnumType::MPEG_2" << " ";
                        break;
                        case TransportEncodingEnumType::MP4:
                        o << "TransportEncodingEnumType::MP4" << " ";
                        break;
                        case TransportEncodingEnumType::OTHER:
                        o << "TransportEncodingEnumType::OTHER" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace TransportEncodingEnumType  

            namespace WaypointKindEnumType {

                std::ostream& operator << (std::ostream& o,const WaypointKindEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case WaypointKindEnumType::APPROACH_FINAL_POINT:
                        o << "WaypointKindEnumType::APPROACH_FINAL_POINT" << " ";
                        break;
                        case WaypointKindEnumType::APPROACH_INITIAL_POINT:
                        o << "WaypointKindEnumType::APPROACH_INITIAL_POINT" << " ";
                        break;
                        case WaypointKindEnumType::LAUNCH:
                        o << "WaypointKindEnumType::LAUNCH" << " ";
                        break;
                        case WaypointKindEnumType::LOITER:
                        o << "WaypointKindEnumType::LOITER" << " ";
                        break;
                        case WaypointKindEnumType::NAV_ONLY:
                        o << "WaypointKindEnumType::NAV_ONLY" << " ";
                        break;
                        case WaypointKindEnumType::NAV_TARGET:
                        o << "WaypointKindEnumType::NAV_TARGET" << " ";
                        break;
                        case WaypointKindEnumType::OTHER:
                        o << "WaypointKindEnumType::OTHER" << " ";
                        break;
                        case WaypointKindEnumType::RECOVERY:
                        o << "WaypointKindEnumType::RECOVERY" << " ";
                        break;
                        case WaypointKindEnumType::RENDEZVOUS:
                        o << "WaypointKindEnumType::RENDEZVOUS" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace WaypointKindEnumType  

            namespace MeteringModeEnumType {

                std::ostream& operator << (std::ostream& o,const MeteringModeEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case MeteringModeEnumType::AUTO_DEFAULT:
                        o << "MeteringModeEnumType::AUTO_DEFAULT" << " ";
                        break;
                        case MeteringModeEnumType::CENTER_WEIGHTED:
                        o << "MeteringModeEnumType::CENTER_WEIGHTED" << " ";
                        break;
                        case MeteringModeEnumType::SPOT:
                        o << "MeteringModeEnumType::SPOT" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace MeteringModeEnumType  

            namespace MountModeEnumType {

                std::ostream& operator << (std::ostream& o,const MountModeEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case MountModeEnumType::_FIXED:
                        o << "MountModeEnumType::_FIXED" << " ";
                        break;
                        case MountModeEnumType::FIXED_BOW_THRUSTER:
                        o << "MountModeEnumType::FIXED_BOW_THRUSTER" << " ";
                        break;
                        case MountModeEnumType::FIXED_PORT_PROPULSOR:
                        o << "MountModeEnumType::FIXED_PORT_PROPULSOR" << " ";
                        break;
                        case MountModeEnumType::FIXED_STERN_THRUSTER:
                        o << "MountModeEnumType::FIXED_STERN_THRUSTER" << " ";
                        break;
                        case MountModeEnumType::VARIABLE_BEARING:
                        o << "MountModeEnumType::VARIABLE_BEARING" << " ";
                        break;
                        case MountModeEnumType::VARIABLE_PITCH:
                        o << "MountModeEnumType::VARIABLE_PITCH" << " ";
                        break;
                        case MountModeEnumType::VARIABLE_PITCH_AND_BEARING:
                        o << "MountModeEnumType::VARIABLE_PITCH_AND_BEARING" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace MountModeEnumType  

            namespace NavigationSolutionEnumType {

                std::ostream& operator << (std::ostream& o,const NavigationSolutionEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case NavigationSolutionEnumType::ESTIMATED:
                        o << "NavigationSolutionEnumType::ESTIMATED" << " ";
                        break;
                        case NavigationSolutionEnumType::GROUND_TRUTH:
                        o << "NavigationSolutionEnumType::GROUND_TRUTH" << " ";
                        break;
                        case NavigationSolutionEnumType::MEASURED:
                        o << "NavigationSolutionEnumType::MEASURED" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace NavigationSolutionEnumType  

            namespace ObstacleAvoidanceEnumType {

                std::ostream& operator << (std::ostream& o,const ObstacleAvoidanceEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case ObstacleAvoidanceEnumType::DEVIATE_FROM_PATH:
                        o << "ObstacleAvoidanceEnumType::DEVIATE_FROM_PATH" << " ";
                        break;
                        case ObstacleAvoidanceEnumType::DO_NOTHING:
                        o << "ObstacleAvoidanceEnumType::DO_NOTHING" << " ";
                        break;
                        case ObstacleAvoidanceEnumType::STOP_ON_PATH:
                        o << "ObstacleAvoidanceEnumType::STOP_ON_PATH" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace ObstacleAvoidanceEnumType  

            namespace PathWayEnumType {

                std::ostream& operator << (std::ostream& o,const PathWayEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case PathWayEnumType::HISTORIAL_GLOBAL:
                        o << "PathWayEnumType::HISTORIAL_GLOBAL" << " ";
                        break;
                        case PathWayEnumType::HISTORICAL_LOCAL:
                        o << "PathWayEnumType::HISTORICAL_LOCAL" << " ";
                        break;
                        case PathWayEnumType::PLANNED_GLOBAL:
                        o << "PathWayEnumType::PLANNED_GLOBAL" << " ";
                        break;
                        case PathWayEnumType::PLANNED_LOCAL:
                        o << "PathWayEnumType::PLANNED_LOCAL" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace PathWayEnumType  

            namespace PlatformModeEnumType {

                std::ostream& operator << (std::ostream& o,const PlatformModeEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case PlatformModeEnumType::MAINTENANCE:
                        o << "PlatformModeEnumType::MAINTENANCE" << " ";
                        break;
                        case PlatformModeEnumType::STANDARD_OPERATING:
                        o << "PlatformModeEnumType::STANDARD_OPERATING" << " ";
                        break;
                        case PlatformModeEnumType::TRAINING:
                        o << "PlatformModeEnumType::TRAINING" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace PlatformModeEnumType  

            namespace PlatformModeTransitionEnumType {

                std::ostream& operator << (std::ostream& o,const PlatformModeTransitionEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case PlatformModeTransitionEnumType::ACTIVE:
                        o << "PlatformModeTransitionEnumType::ACTIVE" << " ";
                        break;
                        case PlatformModeTransitionEnumType::EXITING:
                        o << "PlatformModeTransitionEnumType::EXITING" << " ";
                        break;
                        case PlatformModeTransitionEnumType::INITIALIZING:
                        o << "PlatformModeTransitionEnumType::INITIALIZING" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace PlatformModeTransitionEnumType  

            namespace PowerPlantStateEnumType {

                std::ostream& operator << (std::ostream& o,const PowerPlantStateEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case PowerPlantStateEnumType::FAULT:
                        o << "PowerPlantStateEnumType::FAULT" << " ";
                        break;
                        case PowerPlantStateEnumType::OFF:
                        o << "PowerPlantStateEnumType::OFF" << " ";
                        break;
                        case PowerPlantStateEnumType::ON:
                        o << "PowerPlantStateEnumType::ON" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace PowerPlantStateEnumType  

            namespace PumpStateEnumType {

                std::ostream& operator << (std::ostream& o,const PumpStateEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case PumpStateEnumType::FAULT:
                        o << "PumpStateEnumType::FAULT" << " ";
                        break;
                        case PumpStateEnumType::OFF:
                        o << "PumpStateEnumType::OFF" << " ";
                        break;
                        case PumpStateEnumType::ON_FORWARD:
                        o << "PumpStateEnumType::ON_FORWARD" << " ";
                        break;
                        case PumpStateEnumType::ON_REVERSE:
                        o << "PumpStateEnumType::ON_REVERSE" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace PumpStateEnumType  

            namespace RangeErrorCodeEnumType {

                std::ostream& operator << (std::ostream& o,const RangeErrorCodeEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case RangeErrorCodeEnumType::INVALID_HORIZONTAL_FOV:
                        o << "RangeErrorCodeEnumType::INVALID_HORIZONTAL_FOV" << " ";
                        break;
                        case RangeErrorCodeEnumType::INVALID_SENSOR_RANGE:
                        o << "RangeErrorCodeEnumType::INVALID_SENSOR_RANGE" << " ";
                        break;
                        case RangeErrorCodeEnumType::INVALID_SENSOR_STATE:
                        o << "RangeErrorCodeEnumType::INVALID_SENSOR_STATE" << " ";
                        break;
                        case RangeErrorCodeEnumType::INVALID_UPDATE_RATE:
                        o << "RangeErrorCodeEnumType::INVALID_UPDATE_RATE" << " ";
                        break;
                        case RangeErrorCodeEnumType::INVALID_VERTICAL_FOV:
                        o << "RangeErrorCodeEnumType::INVALID_VERTICAL_FOV" << " ";
                        break;
                        case RangeErrorCodeEnumType::MULTIPLE_INVALID_PARAMETERS:
                        o << "RangeErrorCodeEnumType::MULTIPLE_INVALID_PARAMETERS" << " ";
                        break;
                        case RangeErrorCodeEnumType::UNKNOWN_ERROR_FAULT:
                        o << "RangeErrorCodeEnumType::UNKNOWN_ERROR_FAULT" << " ";
                        break;
                        case RangeErrorCodeEnumType::UNKNOWN_SENSOR_ID:
                        o << "RangeErrorCodeEnumType::UNKNOWN_SENSOR_ID" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace RangeErrorCodeEnumType  

            namespace RenderUselessStateEnumType {

                std::ostream& operator << (std::ostream& o,const RenderUselessStateEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case RenderUselessStateEnumType::NORMAL:
                        o << "RenderUselessStateEnumType::NORMAL" << " ";
                        break;
                        case RenderUselessStateEnumType::RENDERED_USELESS:
                        o << "RenderUselessStateEnumType::RENDERED_USELESS" << " ";
                        break;
                        case RenderUselessStateEnumType::RENDERED_USELESS_FAILED:
                        o << "RenderUselessStateEnumType::RENDERED_USELESS_FAILED" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace RenderUselessStateEnumType  

            namespace SourceIndicatorEnumType {

                std::ostream& operator << (std::ostream& o,const SourceIndicatorEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case SourceIndicatorEnumType::ACTUAL:
                        o << "SourceIndicatorEnumType::ACTUAL" << " ";
                        break;
                        case SourceIndicatorEnumType::GROUND_TRUTH:
                        o << "SourceIndicatorEnumType::GROUND_TRUTH" << " ";
                        break;
                        case SourceIndicatorEnumType::SIMULATED:
                        o << "SourceIndicatorEnumType::SIMULATED" << " ";
                        break;
                        case SourceIndicatorEnumType::TENTATIVE:
                        o << "SourceIndicatorEnumType::TENTATIVE" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace SourceIndicatorEnumType  

            namespace StillImageErrorCodeEnumType {

                std::ostream& operator << (std::ostream& o,const StillImageErrorCodeEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case StillImageErrorCodeEnumType::INVALID_FORMAT:
                        o << "StillImageErrorCodeEnumType::INVALID_FORMAT" << " ";
                        break;
                        case StillImageErrorCodeEnumType::INVALID_FRAME_SIZE:
                        o << "StillImageErrorCodeEnumType::INVALID_FRAME_SIZE" << " ";
                        break;
                        case StillImageErrorCodeEnumType::MULTIPLE_INVALID_PARAMETERS:
                        o << "StillImageErrorCodeEnumType::MULTIPLE_INVALID_PARAMETERS" << " ";
                        break;
                        case StillImageErrorCodeEnumType::UNKNOWN_ERROR_FAULT:
                        o << "StillImageErrorCodeEnumType::UNKNOWN_ERROR_FAULT" << " ";
                        break;
                        case StillImageErrorCodeEnumType::UNKNOWN_SENSOR_ID:
                        o << "StillImageErrorCodeEnumType::UNKNOWN_SENSOR_ID" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace StillImageErrorCodeEnumType  

            namespace StreamStateEnumType {

                std::ostream& operator << (std::ostream& o,const StreamStateEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case StreamStateEnumType::PAUSE:
                        o << "StreamStateEnumType::PAUSE" << " ";
                        break;
                        case StreamStateEnumType::PLAY:
                        o << "StreamStateEnumType::PLAY" << " ";
                        break;
                        case StreamStateEnumType::STOP:
                        o << "StreamStateEnumType::STOP" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace StreamStateEnumType  

            namespace TamperDetectionStateEnumType {

                std::ostream& operator << (std::ostream& o,const TamperDetectionStateEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case TamperDetectionStateEnumType::ALWAYS_ENABLED_OR_CLEAR:
                        o << "TamperDetectionStateEnumType::ALWAYS_ENABLED_OR_CLEAR" << " ";
                        break;
                        case TamperDetectionStateEnumType::DISABLED:
                        o << "TamperDetectionStateEnumType::DISABLED" << " ";
                        break;
                        case TamperDetectionStateEnumType::ENABLED:
                        o << "TamperDetectionStateEnumType::ENABLED" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace TamperDetectionStateEnumType  

            namespace VehicleSpeedModeEnumType {

                std::ostream& operator << (std::ostream& o,const VehicleSpeedModeEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case VehicleSpeedModeEnumType::LRC:
                        o << "VehicleSpeedModeEnumType::LRC" << " ";
                        break;
                        case VehicleSpeedModeEnumType::MEC:
                        o << "VehicleSpeedModeEnumType::MEC" << " ";
                        break;
                        case VehicleSpeedModeEnumType::MRC:
                        o << "VehicleSpeedModeEnumType::MRC" << " ";
                        break;
                        case VehicleSpeedModeEnumType::SLOW:
                        o << "VehicleSpeedModeEnumType::SLOW" << " ";
                        break;
                        case VehicleSpeedModeEnumType::VEHICLE_SPECIFIC:
                        o << "VehicleSpeedModeEnumType::VEHICLE_SPECIFIC" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace VehicleSpeedModeEnumType  

            namespace VehicleSpeedReferenceEnumType {

                std::ostream& operator << (std::ostream& o,const VehicleSpeedReferenceEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case VehicleSpeedReferenceEnumType::SPEED_THROUGH_AIR:
                        o << "VehicleSpeedReferenceEnumType::SPEED_THROUGH_AIR" << " ";
                        break;
                        case VehicleSpeedReferenceEnumType::OTHER:
                        o << "VehicleSpeedReferenceEnumType::OTHER" << " ";
                        break;
                        case VehicleSpeedReferenceEnumType::RPM:
                        o << "VehicleSpeedReferenceEnumType::RPM" << " ";
                        break;
                        case VehicleSpeedReferenceEnumType::SPEED_OVER_GROUND:
                        o << "VehicleSpeedReferenceEnumType::SPEED_OVER_GROUND" << " ";
                        break;
                        case VehicleSpeedReferenceEnumType::SPEED_THROUGH_WATER:
                        o << "VehicleSpeedReferenceEnumType::SPEED_THROUGH_WATER" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace VehicleSpeedReferenceEnumType  

            namespace VelocityCommandTypeEnumType {

                std::ostream& operator << (std::ostream& o,const VelocityCommandTypeEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case VelocityCommandTypeEnumType::CURRENT_COMMAND_SOG:
                        o << "VelocityCommandTypeEnumType::CURRENT_COMMAND_SOG" << " ";
                        break;
                        case VelocityCommandTypeEnumType::CURRENT_COMMAND_SRM:
                        o << "VelocityCommandTypeEnumType::CURRENT_COMMAND_SRM" << " ";
                        break;
                        case VelocityCommandTypeEnumType::DEFAULT_COMMAND_SOG:
                        o << "VelocityCommandTypeEnumType::DEFAULT_COMMAND_SOG" << " ";
                        break;
                        case VelocityCommandTypeEnumType::DEFAULT_COMMAND_SRM:
                        o << "VelocityCommandTypeEnumType::DEFAULT_COMMAND_SRM" << " ";
                        break;
                        case VelocityCommandTypeEnumType::MAX_ALLOWED_SOG:
                        o << "VelocityCommandTypeEnumType::MAX_ALLOWED_SOG" << " ";
                        break;
                        case VelocityCommandTypeEnumType::MAX_ALLOWED_SRM:
                        o << "VelocityCommandTypeEnumType::MAX_ALLOWED_SRM" << " ";
                        break;
                        case VelocityCommandTypeEnumType::MIN_ALLOWED_SOG:
                        o << "VelocityCommandTypeEnumType::MIN_ALLOWED_SOG" << " ";
                        break;
                        case VelocityCommandTypeEnumType::MIN_ALLOWED_SRM:
                        o << "VelocityCommandTypeEnumType::MIN_ALLOWED_SRM" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace VelocityCommandTypeEnumType  

            namespace VideoFormatEnumType {

                std::ostream& operator << (std::ostream& o,const VideoFormatEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case VideoFormatEnumType::NTSCJ:
                        o << "VideoFormatEnumType::NTSCJ" << " ";
                        break;
                        case VideoFormatEnumType::NTSCM:
                        o << "VideoFormatEnumType::NTSCM" << " ";
                        break;
                        case VideoFormatEnumType::PALM:
                        o << "VideoFormatEnumType::PALM" << " ";
                        break;
                        case VideoFormatEnumType::PALN:
                        o << "VideoFormatEnumType::PALN" << " ";
                        break;
                        case VideoFormatEnumType::SECAMBG:
                        o << "VideoFormatEnumType::SECAMBG" << " ";
                        break;
                        case VideoFormatEnumType::SECAML:
                        o << "VideoFormatEnumType::SECAML" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace VideoFormatEnumType  

            namespace VisualClassificationEnumType {

                std::ostream& operator << (std::ostream& o,const VisualClassificationEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case VisualClassificationEnumType::AID_TO_NAVIGATION_CHANNEL_MARKER:
                        o << "VisualClassificationEnumType::AID_TO_NAVIGATION_CHANNEL_MARKER" << " ";
                        break;
                        case VisualClassificationEnumType::MEDIUM_VESSEL_FISHING:
                        o << "VisualClassificationEnumType::MEDIUM_VESSEL_FISHING" << " ";
                        break;
                        case VisualClassificationEnumType::AID_TO_NAVIGATION_GENERAL:
                        o << "VisualClassificationEnumType::AID_TO_NAVIGATION_GENERAL" << " ";
                        break;
                        case VisualClassificationEnumType::SMALL_VESSEL_JET_SKI:
                        o << "VisualClassificationEnumType::SMALL_VESSEL_JET_SKI" << " ";
                        break;
                        case VisualClassificationEnumType::AID_TO_NAVIGATION_LARGE_BUOY:
                        o << "VisualClassificationEnumType::AID_TO_NAVIGATION_LARGE_BUOY" << " ";
                        break;
                        case VisualClassificationEnumType::LARGE_VESSEL_CARGO:
                        o << "VisualClassificationEnumType::LARGE_VESSEL_CARGO" << " ";
                        break;
                        case VisualClassificationEnumType::LARGE_GENERAL_OBSTACLE:
                        o << "VisualClassificationEnumType::LARGE_GENERAL_OBSTACLE" << " ";
                        break;
                        case VisualClassificationEnumType::LARGE_VESSEL_GENERAL:
                        o << "VisualClassificationEnumType::LARGE_VESSEL_GENERAL" << " ";
                        break;
                        case VisualClassificationEnumType::LARGE_VESSEL_MILITARY:
                        o << "VisualClassificationEnumType::LARGE_VESSEL_MILITARY" << " ";
                        break;
                        case VisualClassificationEnumType::LARGE_VESSEL_PASSENGER:
                        o << "VisualClassificationEnumType::LARGE_VESSEL_PASSENGER" << " ";
                        break;
                        case VisualClassificationEnumType::LARGE_VESSEL_OTHER:
                        o << "VisualClassificationEnumType::LARGE_VESSEL_OTHER" << " ";
                        break;
                        case VisualClassificationEnumType::AID_TO_NAVIGATION_LIGHTHOUSE:
                        o << "VisualClassificationEnumType::AID_TO_NAVIGATION_LIGHTHOUSE" << " ";
                        break;
                        case VisualClassificationEnumType::MEDIUM_VESSEL_GENERAL:
                        o << "VisualClassificationEnumType::MEDIUM_VESSEL_GENERAL" << " ";
                        break;
                        case VisualClassificationEnumType::MEDIUM_VESSEL_MILITARY:
                        o << "VisualClassificationEnumType::MEDIUM_VESSEL_MILITARY" << " ";
                        break;
                        case VisualClassificationEnumType::MEDIUM_VESSEL_OTHER:
                        o << "VisualClassificationEnumType::MEDIUM_VESSEL_OTHER" << " ";
                        break;
                        case VisualClassificationEnumType::SMALL_VESSEL_POWER_BOAT:
                        o << "VisualClassificationEnumType::SMALL_VESSEL_POWER_BOAT" << " ";
                        break;
                        case VisualClassificationEnumType::SAILBOAT:
                        o << "VisualClassificationEnumType::SAILBOAT" << " ";
                        break;
                        case VisualClassificationEnumType::AID_TO_NAVIGATION_SMALL_BUOY:
                        o << "VisualClassificationEnumType::AID_TO_NAVIGATION_SMALL_BUOY" << " ";
                        break;
                        case VisualClassificationEnumType::SMALL_GENERAL_OBSTACLE:
                        o << "VisualClassificationEnumType::SMALL_GENERAL_OBSTACLE" << " ";
                        break;
                        case VisualClassificationEnumType::SMALL_VESSEL_GENERAL:
                        o << "VisualClassificationEnumType::SMALL_VESSEL_GENERAL" << " ";
                        break;
                        case VisualClassificationEnumType::SMALL_VESSEL_MILITARY:
                        o << "VisualClassificationEnumType::SMALL_VESSEL_MILITARY" << " ";
                        break;
                        case VisualClassificationEnumType::SMALL_VESSEL_OTHER:
                        o << "VisualClassificationEnumType::SMALL_VESSEL_OTHER" << " ";
                        break;
                        case VisualClassificationEnumType::MEDIUM_VESSEL_TUG:
                        o << "VisualClassificationEnumType::MEDIUM_VESSEL_TUG" << " ";
                        break;
                        case VisualClassificationEnumType::MEDIUM_VESSEL_TUG_IN_TOW:
                        o << "VisualClassificationEnumType::MEDIUM_VESSEL_TUG_IN_TOW" << " ";
                        break;
                        case VisualClassificationEnumType::MEDIUM_VESSEL_YACHT:
                        o << "VisualClassificationEnumType::MEDIUM_VESSEL_YACHT" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace VisualClassificationEnumType  

            namespace WaterTurnDirectionEnumType {

                std::ostream& operator << (std::ostream& o,const WaterTurnDirectionEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case WaterTurnDirectionEnumType::NO_VALID_TURN_DIRECTION:
                        o << "WaterTurnDirectionEnumType::NO_VALID_TURN_DIRECTION" << " ";
                        break;
                        case WaterTurnDirectionEnumType::LEFT_TURN:
                        o << "WaterTurnDirectionEnumType::LEFT_TURN" << " ";
                        break;
                        case WaterTurnDirectionEnumType::RIGHT_TURN:
                        o << "WaterTurnDirectionEnumType::RIGHT_TURN" << " ";
                        break;
                        case WaterTurnDirectionEnumType::VEHICLE_SPECIFIC:
                        o << "WaterTurnDirectionEnumType::VEHICLE_SPECIFIC" << " ";
                        break;
                        case WaterTurnDirectionEnumType::INTO_THE_CURRENT:
                        o << "WaterTurnDirectionEnumType::INTO_THE_CURRENT" << " ";
                        break;
                        case WaterTurnDirectionEnumType::INTO_THE_WIND:
                        o << "WaterTurnDirectionEnumType::INTO_THE_WIND" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace WaterTurnDirectionEnumType  

            namespace WhiteBalanceEnumType {

                std::ostream& operator << (std::ostream& o,const WhiteBalanceEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case WhiteBalanceEnumType::AUTO_DEFAULT:
                        o << "WhiteBalanceEnumType::AUTO_DEFAULT" << " ";
                        break;
                        case WhiteBalanceEnumType::CLOUDY:
                        o << "WhiteBalanceEnumType::CLOUDY" << " ";
                        break;
                        case WhiteBalanceEnumType::DAYLIGHT:
                        o << "WhiteBalanceEnumType::DAYLIGHT" << " ";
                        break;
                        case WhiteBalanceEnumType::FLASH:
                        o << "WhiteBalanceEnumType::FLASH" << " ";
                        break;
                        case WhiteBalanceEnumType::FLUORESCENT:
                        o << "WhiteBalanceEnumType::FLUORESCENT" << " ";
                        break;
                        case WhiteBalanceEnumType::SHADE:
                        o << "WhiteBalanceEnumType::SHADE" << " ";
                        break;
                        case WhiteBalanceEnumType::TUNGSTEN:
                        o << "WhiteBalanceEnumType::TUNGSTEN" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace WhiteBalanceEnumType  

            namespace ZoneKindEnumType {

                std::ostream& operator << (std::ostream& o,const ZoneKindEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case ZoneKindEnumType::KEEP_IN:
                        o << "ZoneKindEnumType::KEEP_IN" << " ";
                        break;
                        case ZoneKindEnumType::KEEP_OUT:
                        o << "ZoneKindEnumType::KEEP_OUT" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace ZoneKindEnumType  

            namespace ZoomModeEnumType {

                std::ostream& operator << (std::ostream& o,const ZoomModeEnumType& sample)
                {
                    ::rti::util::StreamFlagSaver flag_saver (o);
                    switch(sample){
                        case ZoomModeEnumType::ANALOG_ONLY:
                        o << "ZoomModeEnumType::ANALOG_ONLY" << " ";
                        break;
                        case ZoomModeEnumType::DIGITAL_ONLY:
                        o << "ZoomModeEnumType::DIGITAL_ONLY" << " ";
                        break;
                        case ZoomModeEnumType::OFF:
                        o << "ZoomModeEnumType::OFF" << " ";
                        break;
                        case ZoomModeEnumType::MIXED_DEFAULT:
                        o << "ZoomModeEnumType::MIXED_DEFAULT" << " ";
                        break;
                    }
                    return o;
                }

            } // namespace ZoomModeEnumType  

        } // namespace MaritimeEnumeration  

    } // namespace Common  

} // namespace UMAA  

// --- Type traits: -------------------------------------------------

namespace rti { 
    namespace topic {
        #undef ERROR
        #undef VARIABLE_PITCH
        #undef DELETE
        #undef PLATFORM

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::AnalogSensorErrorCodeEnumType::AnalogSensorErrorCodeEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::AnalogSensorErrorCodeEnumType::AnalogSensorErrorCodeEnumType>::value = UMAA::Common::MaritimeEnumeration::AnalogSensorErrorCodeEnumType::AnalogSensorErrorCodeEnumType::INVALID_FORMAT;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::AnalogSensorErrorCodeEnumType::AnalogSensorErrorCodeEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member AnalogSensorErrorCodeEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"INVALID_FORMAT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnalogSensorErrorCodeEnumType::AnalogSensorErrorCodeEnumType::INVALID_FORMAT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"UNKNOWN_ERROR_FAULT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnalogSensorErrorCodeEnumType::AnalogSensorErrorCodeEnumType::UNKNOWN_ERROR_FAULT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"UNKNOWN_SENSOR_ID",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnalogSensorErrorCodeEnumType::AnalogSensorErrorCodeEnumType::UNKNOWN_SENSOR_ID), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode AnalogSensorErrorCodeEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::AnalogSensorErrorCodeEnumType::AnalogSensorErrorCodeEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        AnalogSensorErrorCodeEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for AnalogSensorErrorCodeEnumType*/

                if (is_initialized) {
                    return &AnalogSensorErrorCodeEnumType_g_tc;
                }

                AnalogSensorErrorCodeEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                AnalogSensorErrorCodeEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                AnalogSensorErrorCodeEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                AnalogSensorErrorCodeEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                AnalogSensorErrorCodeEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &AnalogSensorErrorCodeEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo AnalogSensorErrorCodeEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo AnalogSensorErrorCodeEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &AnalogSensorErrorCodeEnumType_g_sampleAccessInfo;
                }

                AnalogSensorErrorCodeEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                AnalogSensorErrorCodeEnumType_g_sampleAccessInfo.memberAccessInfos = 
                AnalogSensorErrorCodeEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::AnalogSensorErrorCodeEnumType::AnalogSensorErrorCodeEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        AnalogSensorErrorCodeEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        AnalogSensorErrorCodeEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                AnalogSensorErrorCodeEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                AnalogSensorErrorCodeEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::AnalogSensorErrorCodeEnumType::AnalogSensorErrorCodeEnumType >;

                AnalogSensorErrorCodeEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &AnalogSensorErrorCodeEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin AnalogSensorErrorCodeEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &AnalogSensorErrorCodeEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::AnalogSensorErrorCodeEnumType::AnalogSensorErrorCodeEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::AnalogSensorErrorCodeEnumType::AnalogSensorErrorCodeEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::AnchorActionEnumType::AnchorActionEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::AnchorActionEnumType::AnchorActionEnumType>::value = UMAA::Common::MaritimeEnumeration::AnchorActionEnumType::AnchorActionEnumType::LOWER;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::AnchorActionEnumType::AnchorActionEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member AnchorActionEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"LOWER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorActionEnumType::AnchorActionEnumType::LOWER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RAISE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorActionEnumType::AnchorActionEnumType::RAISE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"STOP",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorActionEnumType::AnchorActionEnumType::STOP), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode AnchorActionEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::AnchorActionEnumType::AnchorActionEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        AnchorActionEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for AnchorActionEnumType*/

                if (is_initialized) {
                    return &AnchorActionEnumType_g_tc;
                }

                AnchorActionEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                AnchorActionEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                AnchorActionEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                AnchorActionEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                AnchorActionEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &AnchorActionEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo AnchorActionEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo AnchorActionEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &AnchorActionEnumType_g_sampleAccessInfo;
                }

                AnchorActionEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                AnchorActionEnumType_g_sampleAccessInfo.memberAccessInfos = 
                AnchorActionEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::AnchorActionEnumType::AnchorActionEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        AnchorActionEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        AnchorActionEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                AnchorActionEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                AnchorActionEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::AnchorActionEnumType::AnchorActionEnumType >;

                AnchorActionEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &AnchorActionEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin AnchorActionEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &AnchorActionEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::AnchorActionEnumType::AnchorActionEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::AnchorActionEnumType::AnchorActionEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType>::value = UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType::COMMERCIAL_STOCKLESS;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member AnchorKindEnumType_g_tc_members[13]=
                {

                    {
                        (char *)"COMMERCIAL_STOCKLESS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType::COMMERCIAL_STOCKLESS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DANFORTH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType::DANFORTH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FOUR_FLUKE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType::FOUR_FLUKE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GENERAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType::GENERAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LIGHTWEIGHT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType::LIGHTWEIGHT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MARK_2_LWT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType::MARK_2_LWT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MARK_2_STOCKLESS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType::MARK_2_STOCKLESS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MUSHROOM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType::MUSHROOM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NAVY_TYPE_STOCK",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType::NAVY_TYPE_STOCK), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NONMAGNETIC",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType::NONMAGNETIC), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"STANDARD_NAVY_STOCKLESS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType::STANDARD_NAVY_STOCKLESS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"TWO_FLUKE_BALANCED_FLUKE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType::TWO_FLUKE_BALANCED_FLUKE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WEDGE_BLOCK_LWT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType::WEDGE_BLOCK_LWT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode AnchorKindEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        13, /* Number of members */
                        AnchorKindEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for AnchorKindEnumType*/

                if (is_initialized) {
                    return &AnchorKindEnumType_g_tc;
                }

                AnchorKindEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                AnchorKindEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                AnchorKindEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                AnchorKindEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                AnchorKindEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &AnchorKindEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo AnchorKindEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo AnchorKindEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &AnchorKindEnumType_g_sampleAccessInfo;
                }

                AnchorKindEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                AnchorKindEnumType_g_sampleAccessInfo.memberAccessInfos = 
                AnchorKindEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        AnchorKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        AnchorKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                AnchorKindEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                AnchorKindEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType >;

                AnchorKindEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &AnchorKindEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin AnchorKindEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &AnchorKindEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::AnchorKindEnumType::AnchorKindEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::AnchorLocationEnumType::AnchorLocationEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::AnchorLocationEnumType::AnchorLocationEnumType>::value = UMAA::Common::MaritimeEnumeration::AnchorLocationEnumType::AnchorLocationEnumType::BOWER;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::AnchorLocationEnumType::AnchorLocationEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member AnchorLocationEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"BOWER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorLocationEnumType::AnchorLocationEnumType::BOWER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"KEEL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorLocationEnumType::AnchorLocationEnumType::KEEL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"STERN",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorLocationEnumType::AnchorLocationEnumType::STERN), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode AnchorLocationEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::AnchorLocationEnumType::AnchorLocationEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        AnchorLocationEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for AnchorLocationEnumType*/

                if (is_initialized) {
                    return &AnchorLocationEnumType_g_tc;
                }

                AnchorLocationEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                AnchorLocationEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                AnchorLocationEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                AnchorLocationEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                AnchorLocationEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &AnchorLocationEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo AnchorLocationEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo AnchorLocationEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &AnchorLocationEnumType_g_sampleAccessInfo;
                }

                AnchorLocationEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                AnchorLocationEnumType_g_sampleAccessInfo.memberAccessInfos = 
                AnchorLocationEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::AnchorLocationEnumType::AnchorLocationEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        AnchorLocationEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        AnchorLocationEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                AnchorLocationEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                AnchorLocationEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::AnchorLocationEnumType::AnchorLocationEnumType >;

                AnchorLocationEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &AnchorLocationEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin AnchorLocationEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &AnchorLocationEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::AnchorLocationEnumType::AnchorLocationEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::AnchorLocationEnumType::AnchorLocationEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::AnchorStateEnumType::AnchorStateEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::AnchorStateEnumType::AnchorStateEnumType>::value = UMAA::Common::MaritimeEnumeration::AnchorStateEnumType::AnchorStateEnumType::DEPLOYED;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::AnchorStateEnumType::AnchorStateEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member AnchorStateEnumType_g_tc_members[5]=
                {

                    {
                        (char *)"DEPLOYED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorStateEnumType::AnchorStateEnumType::DEPLOYED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LOWERING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorStateEnumType::AnchorStateEnumType::LOWERING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"STOPPED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorStateEnumType::AnchorStateEnumType::STOPPED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RAISING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorStateEnumType::AnchorStateEnumType::RAISING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"STOWED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AnchorStateEnumType::AnchorStateEnumType::STOWED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode AnchorStateEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::AnchorStateEnumType::AnchorStateEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        5, /* Number of members */
                        AnchorStateEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for AnchorStateEnumType*/

                if (is_initialized) {
                    return &AnchorStateEnumType_g_tc;
                }

                AnchorStateEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                AnchorStateEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                AnchorStateEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                AnchorStateEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                AnchorStateEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &AnchorStateEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo AnchorStateEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo AnchorStateEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &AnchorStateEnumType_g_sampleAccessInfo;
                }

                AnchorStateEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                AnchorStateEnumType_g_sampleAccessInfo.memberAccessInfos = 
                AnchorStateEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::AnchorStateEnumType::AnchorStateEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        AnchorStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        AnchorStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                AnchorStateEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                AnchorStateEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::AnchorStateEnumType::AnchorStateEnumType >;

                AnchorStateEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &AnchorStateEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin AnchorStateEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &AnchorStateEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::AnchorStateEnumType::AnchorStateEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::AnchorStateEnumType::AnchorStateEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType>::value = UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType::AVERAGE;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member AudioEncodingQualityEnumType_g_tc_members[7]=
                {

                    {
                        (char *)"AVERAGE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType::AVERAGE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"BEST",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType::BEST), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"BETTER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType::BETTER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GOOD",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType::GOOD), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LESS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType::LESS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"POOR",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType::POOR), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WORST",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType::WORST), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode AudioEncodingQualityEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        7, /* Number of members */
                        AudioEncodingQualityEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for AudioEncodingQualityEnumType*/

                if (is_initialized) {
                    return &AudioEncodingQualityEnumType_g_tc;
                }

                AudioEncodingQualityEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                AudioEncodingQualityEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                AudioEncodingQualityEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                AudioEncodingQualityEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                AudioEncodingQualityEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &AudioEncodingQualityEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo AudioEncodingQualityEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo AudioEncodingQualityEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &AudioEncodingQualityEnumType_g_sampleAccessInfo;
                }

                AudioEncodingQualityEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                AudioEncodingQualityEnumType_g_sampleAccessInfo.memberAccessInfos = 
                AudioEncodingQualityEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        AudioEncodingQualityEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        AudioEncodingQualityEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                AudioEncodingQualityEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                AudioEncodingQualityEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType >;

                AudioEncodingQualityEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &AudioEncodingQualityEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin AudioEncodingQualityEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &AudioEncodingQualityEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::AudioEncodingQualityEnumType::AudioEncodingQualityEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::BearingAngleEnumType::BearingAngleEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::BearingAngleEnumType::BearingAngleEnumType>::value = UMAA::Common::MaritimeEnumeration::BearingAngleEnumType::BearingAngleEnumType::OWNSHIP;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::BearingAngleEnumType::BearingAngleEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member BearingAngleEnumType_g_tc_members[2]=
                {

                    {
                        (char *)"OWNSHIP",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BearingAngleEnumType::BearingAngleEnumType::OWNSHIP), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NORTH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BearingAngleEnumType::BearingAngleEnumType::NORTH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode BearingAngleEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::BearingAngleEnumType::BearingAngleEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        2, /* Number of members */
                        BearingAngleEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for BearingAngleEnumType*/

                if (is_initialized) {
                    return &BearingAngleEnumType_g_tc;
                }

                BearingAngleEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                BearingAngleEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                BearingAngleEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                BearingAngleEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                BearingAngleEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &BearingAngleEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo BearingAngleEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo BearingAngleEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &BearingAngleEnumType_g_sampleAccessInfo;
                }

                BearingAngleEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                BearingAngleEnumType_g_sampleAccessInfo.memberAccessInfos = 
                BearingAngleEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::BearingAngleEnumType::BearingAngleEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        BearingAngleEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        BearingAngleEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                BearingAngleEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                BearingAngleEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::BearingAngleEnumType::BearingAngleEnumType >;

                BearingAngleEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &BearingAngleEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin BearingAngleEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &BearingAngleEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::BearingAngleEnumType::BearingAngleEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::BearingAngleEnumType::BearingAngleEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::BilgeControlEnumType::BilgeControlEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::BilgeControlEnumType::BilgeControlEnumType>::value = UMAA::Common::MaritimeEnumeration::BilgeControlEnumType::BilgeControlEnumType::AUTO;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::BilgeControlEnumType::BilgeControlEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member BilgeControlEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"AUTO",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BilgeControlEnumType::BilgeControlEnumType::AUTO), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"OFF",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BilgeControlEnumType::BilgeControlEnumType::OFF), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ON",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BilgeControlEnumType::BilgeControlEnumType::ON), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode BilgeControlEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::BilgeControlEnumType::BilgeControlEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        BilgeControlEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for BilgeControlEnumType*/

                if (is_initialized) {
                    return &BilgeControlEnumType_g_tc;
                }

                BilgeControlEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                BilgeControlEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                BilgeControlEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                BilgeControlEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                BilgeControlEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &BilgeControlEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo BilgeControlEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo BilgeControlEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &BilgeControlEnumType_g_sampleAccessInfo;
                }

                BilgeControlEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                BilgeControlEnumType_g_sampleAccessInfo.memberAccessInfos = 
                BilgeControlEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::BilgeControlEnumType::BilgeControlEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        BilgeControlEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        BilgeControlEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                BilgeControlEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                BilgeControlEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::BilgeControlEnumType::BilgeControlEnumType >;

                BilgeControlEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &BilgeControlEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin BilgeControlEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &BilgeControlEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::BilgeControlEnumType::BilgeControlEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::BilgeControlEnumType::BilgeControlEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::BilgeStateEnumType::BilgeStateEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::BilgeStateEnumType::BilgeStateEnumType>::value = UMAA::Common::MaritimeEnumeration::BilgeStateEnumType::BilgeStateEnumType::FAULT;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::BilgeStateEnumType::BilgeStateEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member BilgeStateEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"FAULT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BilgeStateEnumType::BilgeStateEnumType::FAULT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"OFF",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BilgeStateEnumType::BilgeStateEnumType::OFF), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ON",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BilgeStateEnumType::BilgeStateEnumType::ON), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode BilgeStateEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::BilgeStateEnumType::BilgeStateEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        BilgeStateEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for BilgeStateEnumType*/

                if (is_initialized) {
                    return &BilgeStateEnumType_g_tc;
                }

                BilgeStateEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                BilgeStateEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                BilgeStateEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                BilgeStateEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                BilgeStateEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &BilgeStateEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo BilgeStateEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo BilgeStateEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &BilgeStateEnumType_g_sampleAccessInfo;
                }

                BilgeStateEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                BilgeStateEnumType_g_sampleAccessInfo.memberAccessInfos = 
                BilgeStateEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::BilgeStateEnumType::BilgeStateEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        BilgeStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        BilgeStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                BilgeStateEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                BilgeStateEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::BilgeStateEnumType::BilgeStateEnumType >;

                BilgeStateEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &BilgeStateEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin BilgeStateEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &BilgeStateEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::BilgeStateEnumType::BilgeStateEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::BilgeStateEnumType::BilgeStateEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType>::value = UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType::TEN_BITS;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member BitDepthEnumType_g_tc_members[12]=
                {

                    {
                        (char *)"TEN_BITS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType::TEN_BITS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"TWELVE_BITS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType::TWELVE_BITS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FOURTEEN_BITS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType::FOURTEEN_BITS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SIXTEEN_BITS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType::SIXTEEN_BITS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"TWENTY_BITS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType::TWENTY_BITS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"TWENTY_FOUR_BITS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType::TWENTY_FOUR_BITS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"THIRTY_TWO_BITS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType::THIRTY_TWO_BITS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FOURTY_BITS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType::FOURTY_BITS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FOURTY_EIGHT_BITS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType::FOURTY_EIGHT_BITS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FIFTY_SIX_BITS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType::FIFTY_SIX_BITS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SIXTY_FOUR_BITS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType::SIXTY_FOUR_BITS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"EIGHT_BITS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType::EIGHT_BITS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode BitDepthEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        12, /* Number of members */
                        BitDepthEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for BitDepthEnumType*/

                if (is_initialized) {
                    return &BitDepthEnumType_g_tc;
                }

                BitDepthEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                BitDepthEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                BitDepthEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                BitDepthEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                BitDepthEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &BitDepthEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo BitDepthEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo BitDepthEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &BitDepthEnumType_g_sampleAccessInfo;
                }

                BitDepthEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                BitDepthEnumType_g_sampleAccessInfo.memberAccessInfos = 
                BitDepthEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        BitDepthEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        BitDepthEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                BitDepthEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                BitDepthEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType >;

                BitDepthEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &BitDepthEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin BitDepthEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &BitDepthEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::BitDepthEnumType::BitDepthEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::BlastConditionEnumType::BlastConditionEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::BlastConditionEnumType::BlastConditionEnumType>::value = UMAA::Common::MaritimeEnumeration::BlastConditionEnumType::BlastConditionEnumType::BLASTING;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::BlastConditionEnumType::BlastConditionEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member BlastConditionEnumType_g_tc_members[2]=
                {

                    {
                        (char *)"BLASTING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BlastConditionEnumType::BlastConditionEnumType::BLASTING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RESTING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BlastConditionEnumType::BlastConditionEnumType::RESTING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode BlastConditionEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::BlastConditionEnumType::BlastConditionEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        2, /* Number of members */
                        BlastConditionEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for BlastConditionEnumType*/

                if (is_initialized) {
                    return &BlastConditionEnumType_g_tc;
                }

                BlastConditionEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                BlastConditionEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                BlastConditionEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                BlastConditionEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                BlastConditionEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &BlastConditionEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo BlastConditionEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo BlastConditionEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &BlastConditionEnumType_g_sampleAccessInfo;
                }

                BlastConditionEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                BlastConditionEnumType_g_sampleAccessInfo.memberAccessInfos = 
                BlastConditionEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::BlastConditionEnumType::BlastConditionEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        BlastConditionEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        BlastConditionEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                BlastConditionEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                BlastConditionEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::BlastConditionEnumType::BlastConditionEnumType >;

                BlastConditionEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &BlastConditionEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin BlastConditionEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &BlastConditionEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::BlastConditionEnumType::BlastConditionEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::BlastConditionEnumType::BlastConditionEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::BlastKindEnumType::BlastKindEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::BlastKindEnumType::BlastKindEnumType>::value = UMAA::Common::MaritimeEnumeration::BlastKindEnumType::BlastKindEnumType::LONG_BLAST;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::BlastKindEnumType::BlastKindEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member BlastKindEnumType_g_tc_members[2]=
                {

                    {
                        (char *)"LONG_BLAST",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BlastKindEnumType::BlastKindEnumType::LONG_BLAST), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SHORT_BLAST",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::BlastKindEnumType::BlastKindEnumType::SHORT_BLAST), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode BlastKindEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::BlastKindEnumType::BlastKindEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        2, /* Number of members */
                        BlastKindEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for BlastKindEnumType*/

                if (is_initialized) {
                    return &BlastKindEnumType_g_tc;
                }

                BlastKindEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                BlastKindEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                BlastKindEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                BlastKindEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                BlastKindEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &BlastKindEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo BlastKindEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo BlastKindEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &BlastKindEnumType_g_sampleAccessInfo;
                }

                BlastKindEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                BlastKindEnumType_g_sampleAccessInfo.memberAccessInfos = 
                BlastKindEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::BlastKindEnumType::BlastKindEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        BlastKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        BlastKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                BlastKindEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                BlastKindEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::BlastKindEnumType::BlastKindEnumType >;

                BlastKindEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &BlastKindEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin BlastKindEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &BlastKindEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::BlastKindEnumType::BlastKindEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::BlastKindEnumType::BlastKindEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::CollisionAvoidStateEnumType::CollisionAvoidStateEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::CollisionAvoidStateEnumType::CollisionAvoidStateEnumType>::value = UMAA::Common::MaritimeEnumeration::CollisionAvoidStateEnumType::CollisionAvoidStateEnumType::DEVIATE_FROM_PATH;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::CollisionAvoidStateEnumType::CollisionAvoidStateEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member CollisionAvoidStateEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"DEVIATE_FROM_PATH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CollisionAvoidStateEnumType::CollisionAvoidStateEnumType::DEVIATE_FROM_PATH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DO_NOTHING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CollisionAvoidStateEnumType::CollisionAvoidStateEnumType::DO_NOTHING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"STOP_ON_PATH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CollisionAvoidStateEnumType::CollisionAvoidStateEnumType::STOP_ON_PATH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode CollisionAvoidStateEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::CollisionAvoidStateEnumType::CollisionAvoidStateEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        CollisionAvoidStateEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for CollisionAvoidStateEnumType*/

                if (is_initialized) {
                    return &CollisionAvoidStateEnumType_g_tc;
                }

                CollisionAvoidStateEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                CollisionAvoidStateEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                CollisionAvoidStateEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                CollisionAvoidStateEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                CollisionAvoidStateEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &CollisionAvoidStateEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo CollisionAvoidStateEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo CollisionAvoidStateEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &CollisionAvoidStateEnumType_g_sampleAccessInfo;
                }

                CollisionAvoidStateEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                CollisionAvoidStateEnumType_g_sampleAccessInfo.memberAccessInfos = 
                CollisionAvoidStateEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::CollisionAvoidStateEnumType::CollisionAvoidStateEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        CollisionAvoidStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        CollisionAvoidStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                CollisionAvoidStateEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                CollisionAvoidStateEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::CollisionAvoidStateEnumType::CollisionAvoidStateEnumType >;

                CollisionAvoidStateEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &CollisionAvoidStateEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin CollisionAvoidStateEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &CollisionAvoidStateEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::CollisionAvoidStateEnumType::CollisionAvoidStateEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::CollisionAvoidStateEnumType::CollisionAvoidStateEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::CollisionAvoidStatusEnumType::CollisionAvoidStatusEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::CollisionAvoidStatusEnumType::CollisionAvoidStatusEnumType>::value = UMAA::Common::MaritimeEnumeration::CollisionAvoidStatusEnumType::CollisionAvoidStatusEnumType::ACTIVE_AVOID_OBSTACLE;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::CollisionAvoidStatusEnumType::CollisionAvoidStatusEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member CollisionAvoidStatusEnumType_g_tc_members[4]=
                {

                    {
                        (char *)"ACTIVE_AVOID_OBSTACLE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CollisionAvoidStatusEnumType::CollisionAvoidStatusEnumType::ACTIVE_AVOID_OBSTACLE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ACTIVE_STOP_ON_OBSTACLE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CollisionAvoidStatusEnumType::CollisionAvoidStatusEnumType::ACTIVE_STOP_ON_OBSTACLE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DISABLED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CollisionAvoidStatusEnumType::CollisionAvoidStatusEnumType::DISABLED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ENABLED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CollisionAvoidStatusEnumType::CollisionAvoidStatusEnumType::ENABLED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode CollisionAvoidStatusEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::CollisionAvoidStatusEnumType::CollisionAvoidStatusEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        4, /* Number of members */
                        CollisionAvoidStatusEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for CollisionAvoidStatusEnumType*/

                if (is_initialized) {
                    return &CollisionAvoidStatusEnumType_g_tc;
                }

                CollisionAvoidStatusEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                CollisionAvoidStatusEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                CollisionAvoidStatusEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                CollisionAvoidStatusEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                CollisionAvoidStatusEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &CollisionAvoidStatusEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo CollisionAvoidStatusEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo CollisionAvoidStatusEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &CollisionAvoidStatusEnumType_g_sampleAccessInfo;
                }

                CollisionAvoidStatusEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                CollisionAvoidStatusEnumType_g_sampleAccessInfo.memberAccessInfos = 
                CollisionAvoidStatusEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::CollisionAvoidStatusEnumType::CollisionAvoidStatusEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        CollisionAvoidStatusEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        CollisionAvoidStatusEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                CollisionAvoidStatusEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                CollisionAvoidStatusEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::CollisionAvoidStatusEnumType::CollisionAvoidStatusEnumType >;

                CollisionAvoidStatusEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &CollisionAvoidStatusEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin CollisionAvoidStatusEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &CollisionAvoidStatusEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::CollisionAvoidStatusEnumType::CollisionAvoidStatusEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::CollisionAvoidStatusEnumType::CollisionAvoidStatusEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType>::value = UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType::POWER_DRIVEN_UNDERWAY;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member COLREGSClassificationEnumType_g_tc_members[10]=
                {

                    {
                        (char *)"POWER_DRIVEN_UNDERWAY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType::POWER_DRIVEN_UNDERWAY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SAILING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType::SAILING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FISHING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType::FISHING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NOT_UNDER_COMMAND",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType::NOT_UNDER_COMMAND), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RESTRICTED_IN_ABILITY_TO_MANUEVER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType::RESTRICTED_IN_ABILITY_TO_MANUEVER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ANCHORED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType::ANCHORED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CONSTRAINED_BY_DRAUGHT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType::CONSTRAINED_BY_DRAUGHT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PUSHING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType::PUSHING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"TOWING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType::TOWING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NON_VESSEL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType::NON_VESSEL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode COLREGSClassificationEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        10, /* Number of members */
                        COLREGSClassificationEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for COLREGSClassificationEnumType*/

                if (is_initialized) {
                    return &COLREGSClassificationEnumType_g_tc;
                }

                COLREGSClassificationEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                COLREGSClassificationEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                COLREGSClassificationEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                COLREGSClassificationEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                COLREGSClassificationEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &COLREGSClassificationEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo COLREGSClassificationEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo COLREGSClassificationEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &COLREGSClassificationEnumType_g_sampleAccessInfo;
                }

                COLREGSClassificationEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                COLREGSClassificationEnumType_g_sampleAccessInfo.memberAccessInfos = 
                COLREGSClassificationEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        COLREGSClassificationEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        COLREGSClassificationEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                COLREGSClassificationEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                COLREGSClassificationEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType >;

                COLREGSClassificationEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &COLREGSClassificationEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin COLREGSClassificationEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &COLREGSClassificationEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::COLREGSClassificationEnumType::COLREGSClassificationEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType>::value = UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType::CANCELED;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member CommandStatusReasonEnumType_g_tc_members[9]=
                {

                    {
                        (char *)"CANCELED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType::CANCELED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"VALIDATION_FAILED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType::VALIDATION_FAILED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"OBJECTIVE_FAILED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType::OBJECTIVE_FAILED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SERVICE_FAILED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType::SERVICE_FAILED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RESOURCE_FAILED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType::RESOURCE_FAILED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RESOURCE_REJECTED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType::RESOURCE_REJECTED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INTERRUPTED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType::INTERRUPTED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"TIMEOUT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType::TIMEOUT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SUCCEEDED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType::SUCCEEDED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode CommandStatusReasonEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        9, /* Number of members */
                        CommandStatusReasonEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for CommandStatusReasonEnumType*/

                if (is_initialized) {
                    return &CommandStatusReasonEnumType_g_tc;
                }

                CommandStatusReasonEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                CommandStatusReasonEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                CommandStatusReasonEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                CommandStatusReasonEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                CommandStatusReasonEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &CommandStatusReasonEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo CommandStatusReasonEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo CommandStatusReasonEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &CommandStatusReasonEnumType_g_sampleAccessInfo;
                }

                CommandStatusReasonEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                CommandStatusReasonEnumType_g_sampleAccessInfo.memberAccessInfos = 
                CommandStatusReasonEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        CommandStatusReasonEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        CommandStatusReasonEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                CommandStatusReasonEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                CommandStatusReasonEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType >;

                CommandStatusReasonEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &CommandStatusReasonEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin CommandStatusReasonEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &CommandStatusReasonEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::CommandStatusReasonEnumType::CommandStatusReasonEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType>::value = UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::BEING_OVERTAKEN_COMPLIANT;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member ContactManeuverInfluenceEnumType_g_tc_members[16]=
                {

                    {
                        (char *)"BEING_OVERTAKEN_COMPLIANT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::BEING_OVERTAKEN_COMPLIANT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"BEING_OVERTAKEN_NONCOMPLIANT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::BEING_OVERTAKEN_NONCOMPLIANT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CROSSING_LEFT_COMPLIANT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::CROSSING_LEFT_COMPLIANT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CROSSING_LEFT_NONCOMPLIANT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::CROSSING_LEFT_NONCOMPLIANT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CROSSING_RIGHT_COMPLIANT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::CROSSING_RIGHT_COMPLIANT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CROSSING_RIGHT_NONCOMPLIANT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::CROSSING_RIGHT_NONCOMPLIANT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"HEAD_ON_COMPLIANT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::HEAD_ON_COMPLIANT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"HEAD_ON_NONCOMPLIANT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::HEAD_ON_NONCOMPLIANT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"OVERTAKING_COMPLIANT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::OVERTAKING_COMPLIANT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"OVERTAKING_NONCOMPLIANT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::OVERTAKING_NONCOMPLIANT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GUIDE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::GUIDE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"IN_EXTREMIS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::IN_EXTREMIS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"COLLISION_AVOIDANCE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::COLLISION_AVOIDANCE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PREEMPTIVE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::PREEMPTIVE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"OBSTACLE_AVOIDANCE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::OBSTACLE_AVOIDANCE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NONE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType::NONE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode ContactManeuverInfluenceEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        16, /* Number of members */
                        ContactManeuverInfluenceEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for ContactManeuverInfluenceEnumType*/

                if (is_initialized) {
                    return &ContactManeuverInfluenceEnumType_g_tc;
                }

                ContactManeuverInfluenceEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                ContactManeuverInfluenceEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                ContactManeuverInfluenceEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                ContactManeuverInfluenceEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                ContactManeuverInfluenceEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &ContactManeuverInfluenceEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo ContactManeuverInfluenceEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo ContactManeuverInfluenceEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &ContactManeuverInfluenceEnumType_g_sampleAccessInfo;
                }

                ContactManeuverInfluenceEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                ContactManeuverInfluenceEnumType_g_sampleAccessInfo.memberAccessInfos = 
                ContactManeuverInfluenceEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        ContactManeuverInfluenceEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        ContactManeuverInfluenceEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                ContactManeuverInfluenceEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                ContactManeuverInfluenceEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType >;

                ContactManeuverInfluenceEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &ContactManeuverInfluenceEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin ContactManeuverInfluenceEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &ContactManeuverInfluenceEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::ContactManeuverInfluenceEnumType::ContactManeuverInfluenceEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::ContingencyBehaviorEnumType::ContingencyBehaviorEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::ContingencyBehaviorEnumType::ContingencyBehaviorEnumType>::value = UMAA::Common::MaritimeEnumeration::ContingencyBehaviorEnumType::ContingencyBehaviorEnumType::CONTINUE;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::ContingencyBehaviorEnumType::ContingencyBehaviorEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member ContingencyBehaviorEnumType_g_tc_members[6]=
                {

                    {
                        (char *)"CONTINUE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContingencyBehaviorEnumType::ContingencyBehaviorEnumType::CONTINUE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FINISH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContingencyBehaviorEnumType::ContingencyBehaviorEnumType::FINISH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LOITER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContingencyBehaviorEnumType::ContingencyBehaviorEnumType::LOITER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NONE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContingencyBehaviorEnumType::ContingencyBehaviorEnumType::NONE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"VEHICLE_SPECIFIC",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContingencyBehaviorEnumType::ContingencyBehaviorEnumType::VEHICLE_SPECIFIC), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"_HOME",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ContingencyBehaviorEnumType::ContingencyBehaviorEnumType::_HOME), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode ContingencyBehaviorEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::ContingencyBehaviorEnumType::ContingencyBehaviorEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        6, /* Number of members */
                        ContingencyBehaviorEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for ContingencyBehaviorEnumType*/

                if (is_initialized) {
                    return &ContingencyBehaviorEnumType_g_tc;
                }

                ContingencyBehaviorEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                ContingencyBehaviorEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                ContingencyBehaviorEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                ContingencyBehaviorEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                ContingencyBehaviorEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &ContingencyBehaviorEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo ContingencyBehaviorEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo ContingencyBehaviorEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &ContingencyBehaviorEnumType_g_sampleAccessInfo;
                }

                ContingencyBehaviorEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                ContingencyBehaviorEnumType_g_sampleAccessInfo.memberAccessInfos = 
                ContingencyBehaviorEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::ContingencyBehaviorEnumType::ContingencyBehaviorEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        ContingencyBehaviorEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        ContingencyBehaviorEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                ContingencyBehaviorEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                ContingencyBehaviorEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::ContingencyBehaviorEnumType::ContingencyBehaviorEnumType >;

                ContingencyBehaviorEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &ContingencyBehaviorEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin ContingencyBehaviorEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &ContingencyBehaviorEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::ContingencyBehaviorEnumType::ContingencyBehaviorEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::ContingencyBehaviorEnumType::ContingencyBehaviorEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::CoordinateSystemEnumType::CoordinateSystemEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::CoordinateSystemEnumType::CoordinateSystemEnumType>::value = UMAA::Common::MaritimeEnumeration::CoordinateSystemEnumType::CoordinateSystemEnumType::SENSOR_COORDINATE_SYSTEM;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::CoordinateSystemEnumType::CoordinateSystemEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member CoordinateSystemEnumType_g_tc_members[2]=
                {

                    {
                        (char *)"SENSOR_COORDINATE_SYSTEM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CoordinateSystemEnumType::CoordinateSystemEnumType::SENSOR_COORDINATE_SYSTEM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"VEHICLE_COORDINATE_SYSTEM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CoordinateSystemEnumType::CoordinateSystemEnumType::VEHICLE_COORDINATE_SYSTEM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode CoordinateSystemEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::CoordinateSystemEnumType::CoordinateSystemEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        2, /* Number of members */
                        CoordinateSystemEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for CoordinateSystemEnumType*/

                if (is_initialized) {
                    return &CoordinateSystemEnumType_g_tc;
                }

                CoordinateSystemEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                CoordinateSystemEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                CoordinateSystemEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                CoordinateSystemEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                CoordinateSystemEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &CoordinateSystemEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo CoordinateSystemEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo CoordinateSystemEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &CoordinateSystemEnumType_g_sampleAccessInfo;
                }

                CoordinateSystemEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                CoordinateSystemEnumType_g_sampleAccessInfo.memberAccessInfos = 
                CoordinateSystemEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::CoordinateSystemEnumType::CoordinateSystemEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        CoordinateSystemEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        CoordinateSystemEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                CoordinateSystemEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                CoordinateSystemEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::CoordinateSystemEnumType::CoordinateSystemEnumType >;

                CoordinateSystemEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &CoordinateSystemEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin CoordinateSystemEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &CoordinateSystemEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::CoordinateSystemEnumType::CoordinateSystemEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::CoordinateSystemEnumType::CoordinateSystemEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType>::value = UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType::EMERGENCY;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member CoreStateEnumType_g_tc_members[8]=
                {

                    {
                        (char *)"EMERGENCY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType::EMERGENCY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FAILURE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType::FAILURE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INITIAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType::INITIAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"READY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType::READY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RESET",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType::RESET), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RESUME",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType::RESUME), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SHUTDOWN",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType::SHUTDOWN), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"STANDBY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType::STANDBY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode CoreStateEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        8, /* Number of members */
                        CoreStateEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for CoreStateEnumType*/

                if (is_initialized) {
                    return &CoreStateEnumType_g_tc;
                }

                CoreStateEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                CoreStateEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                CoreStateEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                CoreStateEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                CoreStateEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &CoreStateEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo CoreStateEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo CoreStateEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &CoreStateEnumType_g_sampleAccessInfo;
                }

                CoreStateEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                CoreStateEnumType_g_sampleAccessInfo.memberAccessInfos = 
                CoreStateEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        CoreStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        CoreStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                CoreStateEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                CoreStateEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType >;

                CoreStateEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &CoreStateEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin CoreStateEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &CoreStateEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::CoreStateEnumType::CoreStateEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType>::value = UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::AAC_MPEG2;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member DigitalAudioFormatEnumType_g_tc_members[18]=
                {

                    {
                        (char *)"AAC_MPEG2",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::AAC_MPEG2), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"AAC_MPEG4",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::AAC_MPEG4), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"AIFF",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::AIFF), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ALAC",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::ALAC), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DOLBY_DIGITAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::DOLBY_DIGITAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DTS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::DTS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FLAC",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::FLAC), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LPCM_PCM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::LPCM_PCM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MP2",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::MP2), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MP3",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::MP3), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"REAL_AUDIO",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::REAL_AUDIO), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SPEEX",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::SPEEX), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"TRUE_AUDIO",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::TRUE_AUDIO), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ULAW",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::ULAW), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"VORBIS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::VORBIS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WAV",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::WAV), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WMA",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::WMA), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WMA9_LOSS_LESS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType::WMA9_LOSS_LESS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode DigitalAudioFormatEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        18, /* Number of members */
                        DigitalAudioFormatEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for DigitalAudioFormatEnumType*/

                if (is_initialized) {
                    return &DigitalAudioFormatEnumType_g_tc;
                }

                DigitalAudioFormatEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                DigitalAudioFormatEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                DigitalAudioFormatEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                DigitalAudioFormatEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                DigitalAudioFormatEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &DigitalAudioFormatEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo DigitalAudioFormatEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo DigitalAudioFormatEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &DigitalAudioFormatEnumType_g_sampleAccessInfo;
                }

                DigitalAudioFormatEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                DigitalAudioFormatEnumType_g_sampleAccessInfo.memberAccessInfos = 
                DigitalAudioFormatEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        DigitalAudioFormatEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        DigitalAudioFormatEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                DigitalAudioFormatEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                DigitalAudioFormatEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType >;

                DigitalAudioFormatEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &DigitalAudioFormatEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin DigitalAudioFormatEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &DigitalAudioFormatEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::DigitalAudioFormatEnumType::DigitalAudioFormatEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType>::value = UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType::INVALID_FORMAT;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member DigitalSensorErrorCodeEnumType_g_tc_members[9]=
                {

                    {
                        (char *)"INVALID_FORMAT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType::INVALID_FORMAT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INVALID_FRAME_SIZE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType::INVALID_FRAME_SIZE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INVALID_MAX_BIT_RATE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType::INVALID_MAX_BIT_RATE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INVALID_MAX_FRAME_RATE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType::INVALID_MAX_FRAME_RATE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INVALID_MIN_BIT_RATE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType::INVALID_MIN_BIT_RATE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INVALID_MIN_FRAME_RATE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType::INVALID_MIN_FRAME_RATE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MULTIPLE_INVALID_PARAMETERS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType::MULTIPLE_INVALID_PARAMETERS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"UNKNOWN_ERROR_FAULT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType::UNKNOWN_ERROR_FAULT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"UNKNOWN_SENSOR_ID",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType::UNKNOWN_SENSOR_ID), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode DigitalSensorErrorCodeEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        9, /* Number of members */
                        DigitalSensorErrorCodeEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for DigitalSensorErrorCodeEnumType*/

                if (is_initialized) {
                    return &DigitalSensorErrorCodeEnumType_g_tc;
                }

                DigitalSensorErrorCodeEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                DigitalSensorErrorCodeEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                DigitalSensorErrorCodeEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                DigitalSensorErrorCodeEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                DigitalSensorErrorCodeEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &DigitalSensorErrorCodeEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo DigitalSensorErrorCodeEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo DigitalSensorErrorCodeEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &DigitalSensorErrorCodeEnumType_g_sampleAccessInfo;
                }

                DigitalSensorErrorCodeEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                DigitalSensorErrorCodeEnumType_g_sampleAccessInfo.memberAccessInfos = 
                DigitalSensorErrorCodeEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        DigitalSensorErrorCodeEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        DigitalSensorErrorCodeEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                DigitalSensorErrorCodeEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                DigitalSensorErrorCodeEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType >;

                DigitalSensorErrorCodeEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &DigitalSensorErrorCodeEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin DigitalSensorErrorCodeEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &DigitalSensorErrorCodeEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::DigitalSensorErrorCodeEnumType::DigitalSensorErrorCodeEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::DomainEnumType::DomainEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::DomainEnumType::DomainEnumType>::value = UMAA::Common::MaritimeEnumeration::DomainEnumType::DomainEnumType::AIR;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::DomainEnumType::DomainEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member DomainEnumType_g_tc_members[4]=
                {

                    {
                        (char *)"AIR",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DomainEnumType::DomainEnumType::AIR), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GROUND",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DomainEnumType::DomainEnumType::GROUND), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SURFACE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DomainEnumType::DomainEnumType::SURFACE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"UNDERSEA",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DomainEnumType::DomainEnumType::UNDERSEA), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode DomainEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::DomainEnumType::DomainEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        4, /* Number of members */
                        DomainEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for DomainEnumType*/

                if (is_initialized) {
                    return &DomainEnumType_g_tc;
                }

                DomainEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                DomainEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                DomainEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                DomainEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                DomainEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &DomainEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo DomainEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo DomainEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &DomainEnumType_g_sampleAccessInfo;
                }

                DomainEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                DomainEnumType_g_sampleAccessInfo.memberAccessInfos = 
                DomainEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::DomainEnumType::DomainEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        DomainEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        DomainEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                DomainEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                DomainEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::DomainEnumType::DomainEnumType >;

                DomainEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &DomainEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin DomainEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &DomainEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::DomainEnumType::DomainEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::DomainEnumType::DomainEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::EngineKindEnumType::EngineKindEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::EngineKindEnumType::EngineKindEnumType>::value = UMAA::Common::MaritimeEnumeration::EngineKindEnumType::EngineKindEnumType::DIESEL;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::EngineKindEnumType::EngineKindEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member EngineKindEnumType_g_tc_members[2]=
                {

                    {
                        (char *)"DIESEL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::EngineKindEnumType::EngineKindEnumType::DIESEL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GAS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::EngineKindEnumType::EngineKindEnumType::GAS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode EngineKindEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::EngineKindEnumType::EngineKindEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        2, /* Number of members */
                        EngineKindEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for EngineKindEnumType*/

                if (is_initialized) {
                    return &EngineKindEnumType_g_tc;
                }

                EngineKindEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                EngineKindEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                EngineKindEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                EngineKindEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                EngineKindEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &EngineKindEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo EngineKindEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo EngineKindEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &EngineKindEnumType_g_sampleAccessInfo;
                }

                EngineKindEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                EngineKindEnumType_g_sampleAccessInfo.memberAccessInfos = 
                EngineKindEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::EngineKindEnumType::EngineKindEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        EngineKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        EngineKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                EngineKindEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                EngineKindEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::EngineKindEnumType::EngineKindEnumType >;

                EngineKindEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &EngineKindEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin EngineKindEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &EngineKindEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::EngineKindEnumType::EngineKindEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::EngineKindEnumType::EngineKindEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType>::value = UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType::ACTUATOR;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member ErrorCodeEnumType_g_tc_members[9]=
                {

                    {
                        (char *)"ACTUATOR",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType::ACTUATOR), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FILESYS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType::FILESYS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NONE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType::NONE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"POWER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType::POWER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PROCESSOR",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType::PROCESSOR), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RAM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType::RAM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ROM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType::ROM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SENSOR",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType::SENSOR), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SOFTWARE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType::SOFTWARE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode ErrorCodeEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        9, /* Number of members */
                        ErrorCodeEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for ErrorCodeEnumType*/

                if (is_initialized) {
                    return &ErrorCodeEnumType_g_tc;
                }

                ErrorCodeEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                ErrorCodeEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                ErrorCodeEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                ErrorCodeEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                ErrorCodeEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &ErrorCodeEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo ErrorCodeEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo ErrorCodeEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &ErrorCodeEnumType_g_sampleAccessInfo;
                }

                ErrorCodeEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                ErrorCodeEnumType_g_sampleAccessInfo.memberAccessInfos = 
                ErrorCodeEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        ErrorCodeEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        ErrorCodeEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                ErrorCodeEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                ErrorCodeEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType >;

                ErrorCodeEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &ErrorCodeEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin ErrorCodeEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &ErrorCodeEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::ErrorCodeEnumType::ErrorCodeEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::ErrorConditionEnumType::ErrorConditionEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::ErrorConditionEnumType::ErrorConditionEnumType>::value = UMAA::Common::MaritimeEnumeration::ErrorConditionEnumType::ErrorConditionEnumType::INFO;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::ErrorConditionEnumType::ErrorConditionEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member ErrorConditionEnumType_g_tc_members[5]=
                {

                    {
                        (char *)"INFO",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ErrorConditionEnumType::ErrorConditionEnumType::INFO), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WARN",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ErrorConditionEnumType::ErrorConditionEnumType::WARN), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ERROR",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ErrorConditionEnumType::ErrorConditionEnumType::ERROR), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FAIL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ErrorConditionEnumType::ErrorConditionEnumType::FAIL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NONE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ErrorConditionEnumType::ErrorConditionEnumType::NONE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode ErrorConditionEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::ErrorConditionEnumType::ErrorConditionEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        5, /* Number of members */
                        ErrorConditionEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for ErrorConditionEnumType*/

                if (is_initialized) {
                    return &ErrorConditionEnumType_g_tc;
                }

                ErrorConditionEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                ErrorConditionEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                ErrorConditionEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                ErrorConditionEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                ErrorConditionEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &ErrorConditionEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo ErrorConditionEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo ErrorConditionEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &ErrorConditionEnumType_g_sampleAccessInfo;
                }

                ErrorConditionEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                ErrorConditionEnumType_g_sampleAccessInfo.memberAccessInfos = 
                ErrorConditionEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::ErrorConditionEnumType::ErrorConditionEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        ErrorConditionEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        ErrorConditionEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                ErrorConditionEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                ErrorConditionEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::ErrorConditionEnumType::ErrorConditionEnumType >;

                ErrorConditionEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &ErrorConditionEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin ErrorConditionEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &ErrorConditionEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::ErrorConditionEnumType::ErrorConditionEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::ErrorConditionEnumType::ErrorConditionEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::ExposureModeEnumType::ExposureModeEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::ExposureModeEnumType::ExposureModeEnumType>::value = UMAA::Common::MaritimeEnumeration::ExposureModeEnumType::ExposureModeEnumType::AUTO_DEFAULT;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::ExposureModeEnumType::ExposureModeEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member ExposureModeEnumType_g_tc_members[4]=
                {

                    {
                        (char *)"AUTO_DEFAULT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ExposureModeEnumType::ExposureModeEnumType::AUTO_DEFAULT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MANUAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ExposureModeEnumType::ExposureModeEnumType::MANUAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"APETURE_PRIORITY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ExposureModeEnumType::ExposureModeEnumType::APETURE_PRIORITY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SHUTTER_PRIORITY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ExposureModeEnumType::ExposureModeEnumType::SHUTTER_PRIORITY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode ExposureModeEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::ExposureModeEnumType::ExposureModeEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        4, /* Number of members */
                        ExposureModeEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for ExposureModeEnumType*/

                if (is_initialized) {
                    return &ExposureModeEnumType_g_tc;
                }

                ExposureModeEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                ExposureModeEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                ExposureModeEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                ExposureModeEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                ExposureModeEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &ExposureModeEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo ExposureModeEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo ExposureModeEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &ExposureModeEnumType_g_sampleAccessInfo;
                }

                ExposureModeEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                ExposureModeEnumType_g_sampleAccessInfo.memberAccessInfos = 
                ExposureModeEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::ExposureModeEnumType::ExposureModeEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        ExposureModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        ExposureModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                ExposureModeEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                ExposureModeEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::ExposureModeEnumType::ExposureModeEnumType >;

                ExposureModeEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &ExposureModeEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin ExposureModeEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &ExposureModeEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::ExposureModeEnumType::ExposureModeEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::ExposureModeEnumType::ExposureModeEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType>::value = UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::CGA_320x200;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member FrameSizeEnumType_g_tc_members[29]=
                {

                    {
                        (char *)"CGA_320x200",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::CGA_320x200), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CIF_1408x1152",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::CIF_1408x1152), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CIF_352x288",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::CIF_352x288), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CIF_704x576",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::CIF_704x576), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"EGA_640x350",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::EGA_640x350), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"HD1080_1920x1080",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::HD1080_1920x1080), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"HD480_852x480",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::HD480_852x480), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"HD720_1280x720",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::HD720_1280x720), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"HSXGA_5120x4096",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::HSXGA_5120x4096), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"QCIF_176x144",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::QCIF_176x144), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"QQVGA_160x120",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::QQVGA_160x120), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"QSXGA_2560x2048",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::QSXGA_2560x2048), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"QVGA_320x240",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::QVGA_320x240), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"QXGA_2048x1536",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::QXGA_2048x1536), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SQCIF_128x96",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::SQCIF_128x96), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SVGA_800x600",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::SVGA_800x600), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SXGA_1280x1024",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::SXGA_1280x1024), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"UXGA_1600x1200",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::UXGA_1600x1200), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"VGA_640x480",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::VGA_640x480), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WHSXGA_6400x4096",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::WHSXGA_6400x4096), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WHUXGA_7680x4800",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::WHUXGA_7680x4800), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WOXGA_2560x1600",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::WOXGA_2560x1600), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WQSXGA_3200x2048",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::WQSXGA_3200x2048), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WQUXGA_3840x2400",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::WQUXGA_3840x2400), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WSXGA_1600x1024",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::WSXGA_1600x1024), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WUXGA_1920x1200",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::WUXGA_1920x1200), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WVGA_852x480",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::WVGA_852x480), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WXGA_1366x768",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::WXGA_1366x768), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"XGA_1024x768",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType::XGA_1024x768), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode FrameSizeEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        29, /* Number of members */
                        FrameSizeEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for FrameSizeEnumType*/

                if (is_initialized) {
                    return &FrameSizeEnumType_g_tc;
                }

                FrameSizeEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                FrameSizeEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                FrameSizeEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                FrameSizeEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                FrameSizeEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &FrameSizeEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo FrameSizeEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo FrameSizeEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &FrameSizeEnumType_g_sampleAccessInfo;
                }

                FrameSizeEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                FrameSizeEnumType_g_sampleAccessInfo.memberAccessInfos = 
                FrameSizeEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        FrameSizeEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        FrameSizeEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                FrameSizeEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                FrameSizeEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType >;

                FrameSizeEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &FrameSizeEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin FrameSizeEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &FrameSizeEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::FrameSizeEnumType::FrameSizeEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType>::value = UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType::UNKNOWN;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member GPSConstellationEnumType_g_tc_members[8]=
                {

                    {
                        (char *)"UNKNOWN",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType::UNKNOWN), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"BEIDOU",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType::BEIDOU), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GALILEO",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType::GALILEO), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GLONASS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType::GLONASS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GPS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType::GPS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"IRNSS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType::IRNSS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"QZSS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType::QZSS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SBAS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType::SBAS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode GPSConstellationEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        8, /* Number of members */
                        GPSConstellationEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for GPSConstellationEnumType*/

                if (is_initialized) {
                    return &GPSConstellationEnumType_g_tc;
                }

                GPSConstellationEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                GPSConstellationEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                GPSConstellationEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                GPSConstellationEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                GPSConstellationEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &GPSConstellationEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo GPSConstellationEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo GPSConstellationEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &GPSConstellationEnumType_g_sampleAccessInfo;
                }

                GPSConstellationEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                GPSConstellationEnumType_g_sampleAccessInfo.memberAccessInfos = 
                GPSConstellationEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        GPSConstellationEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        GPSConstellationEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                GPSConstellationEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                GPSConstellationEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType >;

                GPSConstellationEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &GPSConstellationEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin GPSConstellationEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &GPSConstellationEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::GPSConstellationEnumType::GPSConstellationEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::GPSFixEnumType::GPSFixEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::GPSFixEnumType::GPSFixEnumType>::value = UMAA::Common::MaritimeEnumeration::GPSFixEnumType::GPSFixEnumType::INITIATING;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::GPSFixEnumType::GPSFixEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member GPSFixEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"INITIATING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSFixEnumType::GPSFixEnumType::INITIATING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PERFORMING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSFixEnumType::GPSFixEnumType::PERFORMING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"STABLE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSFixEnumType::GPSFixEnumType::STABLE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode GPSFixEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::GPSFixEnumType::GPSFixEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        GPSFixEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for GPSFixEnumType*/

                if (is_initialized) {
                    return &GPSFixEnumType_g_tc;
                }

                GPSFixEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                GPSFixEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                GPSFixEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                GPSFixEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                GPSFixEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &GPSFixEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo GPSFixEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo GPSFixEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &GPSFixEnumType_g_sampleAccessInfo;
                }

                GPSFixEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                GPSFixEnumType_g_sampleAccessInfo.memberAccessInfos = 
                GPSFixEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::GPSFixEnumType::GPSFixEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        GPSFixEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        GPSFixEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                GPSFixEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                GPSFixEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::GPSFixEnumType::GPSFixEnumType >;

                GPSFixEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &GPSFixEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin GPSFixEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &GPSFixEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::GPSFixEnumType::GPSFixEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::GPSFixEnumType::GPSFixEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType>::value = UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType::GPS_1;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member GPSNavigationSolutionEnumType_g_tc_members[8]=
                {

                    {
                        (char *)"GPS_1",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType::GPS_1), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GPS_2",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType::GPS_2), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GPS_2D",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType::GPS_2D), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GPS_3",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType::GPS_3), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GPS_3D",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType::GPS_3D), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GPS_4",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType::GPS_4), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GPS_DEAD_RECK",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType::GPS_DEAD_RECK), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NO_NAV",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType::NO_NAV), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode GPSNavigationSolutionEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        8, /* Number of members */
                        GPSNavigationSolutionEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for GPSNavigationSolutionEnumType*/

                if (is_initialized) {
                    return &GPSNavigationSolutionEnumType_g_tc;
                }

                GPSNavigationSolutionEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                GPSNavigationSolutionEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                GPSNavigationSolutionEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                GPSNavigationSolutionEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                GPSNavigationSolutionEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &GPSNavigationSolutionEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo GPSNavigationSolutionEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo GPSNavigationSolutionEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &GPSNavigationSolutionEnumType_g_sampleAccessInfo;
                }

                GPSNavigationSolutionEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                GPSNavigationSolutionEnumType_g_sampleAccessInfo.memberAccessInfos = 
                GPSNavigationSolutionEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        GPSNavigationSolutionEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        GPSNavigationSolutionEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                GPSNavigationSolutionEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                GPSNavigationSolutionEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType >;

                GPSNavigationSolutionEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &GPSNavigationSolutionEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin GPSNavigationSolutionEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &GPSNavigationSolutionEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::GPSNavigationSolutionEnumType::GPSNavigationSolutionEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::GuardedTeleoperationStatusEnumType::GuardedTeleoperationStatusEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::GuardedTeleoperationStatusEnumType::GuardedTeleoperationStatusEnumType>::value = UMAA::Common::MaritimeEnumeration::GuardedTeleoperationStatusEnumType::GuardedTeleoperationStatusEnumType::DISABLED;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::GuardedTeleoperationStatusEnumType::GuardedTeleoperationStatusEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member GuardedTeleoperationStatusEnumType_g_tc_members[6]=
                {

                    {
                        (char *)"DISABLED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GuardedTeleoperationStatusEnumType::GuardedTeleoperationStatusEnumType::DISABLED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ENABLED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GuardedTeleoperationStatusEnumType::GuardedTeleoperationStatusEnumType::ENABLED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ACTIVE_AVOID_OBSTACLE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GuardedTeleoperationStatusEnumType::GuardedTeleoperationStatusEnumType::ACTIVE_AVOID_OBSTACLE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PITCHOVER_LIMIT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GuardedTeleoperationStatusEnumType::GuardedTeleoperationStatusEnumType::PITCHOVER_LIMIT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ROLLOVER_LIMIT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GuardedTeleoperationStatusEnumType::GuardedTeleoperationStatusEnumType::ROLLOVER_LIMIT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ACTIVE_STOP_ON_OBSTACLE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::GuardedTeleoperationStatusEnumType::GuardedTeleoperationStatusEnumType::ACTIVE_STOP_ON_OBSTACLE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode GuardedTeleoperationStatusEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::GuardedTeleoperationStatusEnumType::GuardedTeleoperationStatusEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        6, /* Number of members */
                        GuardedTeleoperationStatusEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for GuardedTeleoperationStatusEnumType*/

                if (is_initialized) {
                    return &GuardedTeleoperationStatusEnumType_g_tc;
                }

                GuardedTeleoperationStatusEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                GuardedTeleoperationStatusEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                GuardedTeleoperationStatusEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                GuardedTeleoperationStatusEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                GuardedTeleoperationStatusEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &GuardedTeleoperationStatusEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo GuardedTeleoperationStatusEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo GuardedTeleoperationStatusEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &GuardedTeleoperationStatusEnumType_g_sampleAccessInfo;
                }

                GuardedTeleoperationStatusEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                GuardedTeleoperationStatusEnumType_g_sampleAccessInfo.memberAccessInfos = 
                GuardedTeleoperationStatusEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::GuardedTeleoperationStatusEnumType::GuardedTeleoperationStatusEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        GuardedTeleoperationStatusEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        GuardedTeleoperationStatusEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                GuardedTeleoperationStatusEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                GuardedTeleoperationStatusEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::GuardedTeleoperationStatusEnumType::GuardedTeleoperationStatusEnumType >;

                GuardedTeleoperationStatusEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &GuardedTeleoperationStatusEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin GuardedTeleoperationStatusEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &GuardedTeleoperationStatusEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::GuardedTeleoperationStatusEnumType::GuardedTeleoperationStatusEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::GuardedTeleoperationStatusEnumType::GuardedTeleoperationStatusEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType>::value = UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::BASELINE;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member H264EncodingEnumType_g_tc_members[21]=
                {

                    {
                        (char *)"BASELINE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::BASELINE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CAVLC444",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::CAVLC444), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CONSTRAINED_BASELINE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::CONSTRAINED_BASELINE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CONSTRAINED_HIGH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::CONSTRAINED_HIGH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"EXTENDED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::EXTENDED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"HIGH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::HIGH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"HIGH10",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::HIGH10), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"HIGH10_INTRA",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::HIGH10_INTRA), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"HIGH422",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::HIGH422), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"HIGH422_INTRA",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::HIGH422_INTRA), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"HIGH444_INTRA",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::HIGH444_INTRA), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"HIGH444_PREDICTIVE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::HIGH444_PREDICTIVE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MAIN",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::MAIN), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MULTIVIEW_HIGH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::MULTIVIEW_HIGH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PROGRESSIVE_HIGH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::PROGRESSIVE_HIGH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SCALABLE_BASELINE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::SCALABLE_BASELINE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SCALABLE_CONSTRAINED_BASELINE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::SCALABLE_CONSTRAINED_BASELINE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SCALABLE_CONSTRAINED_HIGH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::SCALABLE_CONSTRAINED_HIGH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SCALABLE_HIGH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::SCALABLE_HIGH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SCALABLE_HIGH_INTRA",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::SCALABLE_HIGH_INTRA), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"STEREO_HIGH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType::STEREO_HIGH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode H264EncodingEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        21, /* Number of members */
                        H264EncodingEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for H264EncodingEnumType*/

                if (is_initialized) {
                    return &H264EncodingEnumType_g_tc;
                }

                H264EncodingEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                H264EncodingEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                H264EncodingEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                H264EncodingEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                H264EncodingEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &H264EncodingEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo H264EncodingEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo H264EncodingEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &H264EncodingEnumType_g_sampleAccessInfo;
                }

                H264EncodingEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                H264EncodingEnumType_g_sampleAccessInfo.memberAccessInfos = 
                H264EncodingEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        H264EncodingEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        H264EncodingEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                H264EncodingEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                H264EncodingEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType >;

                H264EncodingEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &H264EncodingEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin H264EncodingEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &H264EncodingEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::H264EncodingEnumType::H264EncodingEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType>::value = UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType::BEST_QUALITY;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member H264PresetEnumType_g_tc_members[10]=
                {

                    {
                        (char *)"BEST_QUALITY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType::BEST_QUALITY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DRIVE_VISION",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType::DRIVE_VISION), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LOW_LATENCY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType::LOW_LATENCY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MANIPULATION",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType::MANIPULATION), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PERSISTENT_STARE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType::PERSISTENT_STARE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PROGRAM_SPECIFIC_1",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType::PROGRAM_SPECIFIC_1), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PROGRAM_SPECIFIC_2",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType::PROGRAM_SPECIFIC_2), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PROGRAM_SPECIFIC_3",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType::PROGRAM_SPECIFIC_3), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PROGRAM_SPECIFIC_4",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType::PROGRAM_SPECIFIC_4), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SLOW_COMMS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType::SLOW_COMMS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode H264PresetEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        10, /* Number of members */
                        H264PresetEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for H264PresetEnumType*/

                if (is_initialized) {
                    return &H264PresetEnumType_g_tc;
                }

                H264PresetEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                H264PresetEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                H264PresetEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                H264PresetEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                H264PresetEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &H264PresetEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo H264PresetEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo H264PresetEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &H264PresetEnumType_g_sampleAccessInfo;
                }

                H264PresetEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                H264PresetEnumType_g_sampleAccessInfo.memberAccessInfos = 
                H264PresetEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        H264PresetEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        H264PresetEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                H264PresetEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                H264PresetEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType >;

                H264PresetEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &H264PresetEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin H264PresetEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &H264PresetEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::H264PresetEnumType::H264PresetEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::HandoverResultEnumType::HandoverResultEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::HandoverResultEnumType::HandoverResultEnumType>::value = UMAA::Common::MaritimeEnumeration::HandoverResultEnumType::HandoverResultEnumType::DEFERRED;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::HandoverResultEnumType::HandoverResultEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member HandoverResultEnumType_g_tc_members[6]=
                {

                    {
                        (char *)"DEFERRED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::HandoverResultEnumType::HandoverResultEnumType::DEFERRED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DENIED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::HandoverResultEnumType::HandoverResultEnumType::DENIED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GRANTED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::HandoverResultEnumType::HandoverResultEnumType::GRANTED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"TIMEOUT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::HandoverResultEnumType::HandoverResultEnumType::TIMEOUT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INSUFFICIENT_AUTHORITY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::HandoverResultEnumType::HandoverResultEnumType::INSUFFICIENT_AUTHORITY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NOT_AVAILABLE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::HandoverResultEnumType::HandoverResultEnumType::NOT_AVAILABLE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode HandoverResultEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::HandoverResultEnumType::HandoverResultEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        6, /* Number of members */
                        HandoverResultEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for HandoverResultEnumType*/

                if (is_initialized) {
                    return &HandoverResultEnumType_g_tc;
                }

                HandoverResultEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                HandoverResultEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                HandoverResultEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                HandoverResultEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                HandoverResultEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &HandoverResultEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo HandoverResultEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo HandoverResultEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &HandoverResultEnumType_g_sampleAccessInfo;
                }

                HandoverResultEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                HandoverResultEnumType_g_sampleAccessInfo.memberAccessInfos = 
                HandoverResultEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::HandoverResultEnumType::HandoverResultEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        HandoverResultEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        HandoverResultEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                HandoverResultEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                HandoverResultEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::HandoverResultEnumType::HandoverResultEnumType >;

                HandoverResultEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &HandoverResultEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin HandoverResultEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &HandoverResultEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::HandoverResultEnumType::HandoverResultEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::HandoverResultEnumType::HandoverResultEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::HeadingReferenceEnumType::HeadingReferenceEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::HeadingReferenceEnumType::HeadingReferenceEnumType>::value = UMAA::Common::MaritimeEnumeration::HeadingReferenceEnumType::HeadingReferenceEnumType::MAGNETIC_NORTH;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::HeadingReferenceEnumType::HeadingReferenceEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member HeadingReferenceEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"MAGNETIC_NORTH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::HeadingReferenceEnumType::HeadingReferenceEnumType::MAGNETIC_NORTH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"TRUE_NORTH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::HeadingReferenceEnumType::HeadingReferenceEnumType::TRUE_NORTH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"WIND_DIRECTION",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::HeadingReferenceEnumType::HeadingReferenceEnumType::WIND_DIRECTION), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode HeadingReferenceEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::HeadingReferenceEnumType::HeadingReferenceEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        HeadingReferenceEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for HeadingReferenceEnumType*/

                if (is_initialized) {
                    return &HeadingReferenceEnumType_g_tc;
                }

                HeadingReferenceEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                HeadingReferenceEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                HeadingReferenceEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                HeadingReferenceEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                HeadingReferenceEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &HeadingReferenceEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo HeadingReferenceEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo HeadingReferenceEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &HeadingReferenceEnumType_g_sampleAccessInfo;
                }

                HeadingReferenceEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                HeadingReferenceEnumType_g_sampleAccessInfo.memberAccessInfos = 
                HeadingReferenceEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::HeadingReferenceEnumType::HeadingReferenceEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        HeadingReferenceEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        HeadingReferenceEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                HeadingReferenceEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                HeadingReferenceEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::HeadingReferenceEnumType::HeadingReferenceEnumType >;

                HeadingReferenceEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &HeadingReferenceEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin HeadingReferenceEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &HeadingReferenceEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::HeadingReferenceEnumType::HeadingReferenceEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::HeadingReferenceEnumType::HeadingReferenceEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::HeightModeEnumType::HeightModeEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::HeightModeEnumType::HeightModeEnumType>::value = UMAA::Common::MaritimeEnumeration::HeightModeEnumType::HeightModeEnumType::ALTITUDE;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::HeightModeEnumType::HeightModeEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member HeightModeEnumType_g_tc_members[2]=
                {

                    {
                        (char *)"ALTITUDE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::HeightModeEnumType::HeightModeEnumType::ALTITUDE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DEPTH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::HeightModeEnumType::HeightModeEnumType::DEPTH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode HeightModeEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::HeightModeEnumType::HeightModeEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        2, /* Number of members */
                        HeightModeEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for HeightModeEnumType*/

                if (is_initialized) {
                    return &HeightModeEnumType_g_tc;
                }

                HeightModeEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                HeightModeEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                HeightModeEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                HeightModeEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                HeightModeEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &HeightModeEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo HeightModeEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo HeightModeEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &HeightModeEnumType_g_sampleAccessInfo;
                }

                HeightModeEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                HeightModeEnumType_g_sampleAccessInfo.memberAccessInfos = 
                HeightModeEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::HeightModeEnumType::HeightModeEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        HeightModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        HeightModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                HeightModeEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                HeightModeEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::HeightModeEnumType::HeightModeEnumType >;

                HeightModeEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &HeightModeEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin HeightModeEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &HeightModeEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::HeightModeEnumType::HeightModeEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::HeightModeEnumType::HeightModeEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::HoverKindEnumType::HoverKindEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::HoverKindEnumType::HoverKindEnumType>::value = UMAA::Common::MaritimeEnumeration::HoverKindEnumType::HoverKindEnumType::LAT_LON_PRIORITY;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::HoverKindEnumType::HoverKindEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member HoverKindEnumType_g_tc_members[2]=
                {

                    {
                        (char *)"LAT_LON_PRIORITY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::HoverKindEnumType::HoverKindEnumType::LAT_LON_PRIORITY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"Z_PRIORITY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::HoverKindEnumType::HoverKindEnumType::Z_PRIORITY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode HoverKindEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::HoverKindEnumType::HoverKindEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        2, /* Number of members */
                        HoverKindEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for HoverKindEnumType*/

                if (is_initialized) {
                    return &HoverKindEnumType_g_tc;
                }

                HoverKindEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                HoverKindEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                HoverKindEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                HoverKindEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                HoverKindEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &HoverKindEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo HoverKindEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo HoverKindEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &HoverKindEnumType_g_sampleAccessInfo;
                }

                HoverKindEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                HoverKindEnumType_g_sampleAccessInfo.memberAccessInfos = 
                HoverKindEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::HoverKindEnumType::HoverKindEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        HoverKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        HoverKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                HoverKindEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                HoverKindEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::HoverKindEnumType::HoverKindEnumType >;

                HoverKindEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &HoverKindEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin HoverKindEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &HoverKindEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::HoverKindEnumType::HoverKindEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::HoverKindEnumType::HoverKindEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::IgnitionStateEnumType::IgnitionStateEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::IgnitionStateEnumType::IgnitionStateEnumType>::value = UMAA::Common::MaritimeEnumeration::IgnitionStateEnumType::IgnitionStateEnumType::OFF;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::IgnitionStateEnumType::IgnitionStateEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member IgnitionStateEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"OFF",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::IgnitionStateEnumType::IgnitionStateEnumType::OFF), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RUN",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::IgnitionStateEnumType::IgnitionStateEnumType::RUN), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"START",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::IgnitionStateEnumType::IgnitionStateEnumType::START), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode IgnitionStateEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::IgnitionStateEnumType::IgnitionStateEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        IgnitionStateEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for IgnitionStateEnumType*/

                if (is_initialized) {
                    return &IgnitionStateEnumType_g_tc;
                }

                IgnitionStateEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                IgnitionStateEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                IgnitionStateEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                IgnitionStateEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                IgnitionStateEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &IgnitionStateEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo IgnitionStateEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo IgnitionStateEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &IgnitionStateEnumType_g_sampleAccessInfo;
                }

                IgnitionStateEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                IgnitionStateEnumType_g_sampleAccessInfo.memberAccessInfos = 
                IgnitionStateEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::IgnitionStateEnumType::IgnitionStateEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        IgnitionStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        IgnitionStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                IgnitionStateEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                IgnitionStateEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::IgnitionStateEnumType::IgnitionStateEnumType >;

                IgnitionStateEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &IgnitionStateEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin IgnitionStateEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &IgnitionStateEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::IgnitionStateEnumType::IgnitionStateEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::IgnitionStateEnumType::IgnitionStateEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType>::value = UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType::BMP;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member ImageFormatEnumType_g_tc_members[11]=
                {

                    {
                        (char *)"BMP",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType::BMP), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CR2_RAW",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType::CR2_RAW), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DNG",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType::DNG), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GIF",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType::GIF), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"JPEG",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType::JPEG), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NEF",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType::NEF), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PGM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType::PGM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PNG",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType::PNG), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PNM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType::PNM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PPM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType::PPM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"TIFF",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType::TIFF), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode ImageFormatEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        11, /* Number of members */
                        ImageFormatEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for ImageFormatEnumType*/

                if (is_initialized) {
                    return &ImageFormatEnumType_g_tc;
                }

                ImageFormatEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                ImageFormatEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                ImageFormatEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                ImageFormatEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                ImageFormatEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &ImageFormatEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo ImageFormatEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo ImageFormatEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &ImageFormatEnumType_g_sampleAccessInfo;
                }

                ImageFormatEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                ImageFormatEnumType_g_sampleAccessInfo.memberAccessInfos = 
                ImageFormatEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        ImageFormatEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        ImageFormatEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                ImageFormatEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                ImageFormatEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType >;

                ImageFormatEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &ImageFormatEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin ImageFormatEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &ImageFormatEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::ImageFormatEnumType::ImageFormatEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::ImagingModeEnumType::ImagingModeEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::ImagingModeEnumType::ImagingModeEnumType>::value = UMAA::Common::MaritimeEnumeration::ImagingModeEnumType::ImagingModeEnumType::COLOR;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::ImagingModeEnumType::ImagingModeEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member ImagingModeEnumType_g_tc_members[4]=
                {

                    {
                        (char *)"COLOR",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ImagingModeEnumType::ImagingModeEnumType::COLOR), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GREYSCALE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ImagingModeEnumType::ImagingModeEnumType::GREYSCALE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INFRARED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ImagingModeEnumType::ImagingModeEnumType::INFRARED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LOWLIGHT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ImagingModeEnumType::ImagingModeEnumType::LOWLIGHT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode ImagingModeEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::ImagingModeEnumType::ImagingModeEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        4, /* Number of members */
                        ImagingModeEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for ImagingModeEnumType*/

                if (is_initialized) {
                    return &ImagingModeEnumType_g_tc;
                }

                ImagingModeEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                ImagingModeEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                ImagingModeEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                ImagingModeEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                ImagingModeEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &ImagingModeEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo ImagingModeEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo ImagingModeEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &ImagingModeEnumType_g_sampleAccessInfo;
                }

                ImagingModeEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                ImagingModeEnumType_g_sampleAccessInfo.memberAccessInfos = 
                ImagingModeEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::ImagingModeEnumType::ImagingModeEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        ImagingModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        ImagingModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                ImagingModeEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                ImagingModeEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::ImagingModeEnumType::ImagingModeEnumType >;

                ImagingModeEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &ImagingModeEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin ImagingModeEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &ImagingModeEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::ImagingModeEnumType::ImagingModeEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::ImagingModeEnumType::ImagingModeEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType>::value = UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType::COURSE_GPS_ALIGNMENT;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member InertialSensorOpStatusEnumType_g_tc_members[9]=
                {

                    {
                        (char *)"COURSE_GPS_ALIGNMENT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType::COURSE_GPS_ALIGNMENT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"COURSE_STATIONARY_ALIGNMENT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType::COURSE_STATIONARY_ALIGNMENT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FINE_GPS_ALIGNMENT_COMPLETE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType::FINE_GPS_ALIGNMENT_COMPLETE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FINE_GPS_ALIGNMENT_STARTED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType::FINE_GPS_ALIGNMENT_STARTED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FINE_STATIONARY_ALIGNMENT_COMPLETE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType::FINE_STATIONARY_ALIGNMENT_COMPLETE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FINE_STATIONARY_ALIGNMENT_STARTED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType::FINE_STATIONARY_ALIGNMENT_STARTED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INERTIAL_SENSOR_FAILURE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType::INERTIAL_SENSOR_FAILURE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INIT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType::INIT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"OPERATIONAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType::OPERATIONAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode InertialSensorOpStatusEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        9, /* Number of members */
                        InertialSensorOpStatusEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for InertialSensorOpStatusEnumType*/

                if (is_initialized) {
                    return &InertialSensorOpStatusEnumType_g_tc;
                }

                InertialSensorOpStatusEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                InertialSensorOpStatusEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                InertialSensorOpStatusEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                InertialSensorOpStatusEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                InertialSensorOpStatusEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &InertialSensorOpStatusEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo InertialSensorOpStatusEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo InertialSensorOpStatusEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &InertialSensorOpStatusEnumType_g_sampleAccessInfo;
                }

                InertialSensorOpStatusEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                InertialSensorOpStatusEnumType_g_sampleAccessInfo.memberAccessInfos = 
                InertialSensorOpStatusEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        InertialSensorOpStatusEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        InertialSensorOpStatusEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                InertialSensorOpStatusEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                InertialSensorOpStatusEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType >;

                InertialSensorOpStatusEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &InertialSensorOpStatusEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin InertialSensorOpStatusEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &InertialSensorOpStatusEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::InertialSensorOpStatusEnumType::InertialSensorOpStatusEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::InertialSensorStateEnumType::InertialSensorStateEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::InertialSensorStateEnumType::InertialSensorStateEnumType>::value = UMAA::Common::MaritimeEnumeration::InertialSensorStateEnumType::InertialSensorStateEnumType::OFF;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::InertialSensorStateEnumType::InertialSensorStateEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member InertialSensorStateEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"OFF",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::InertialSensorStateEnumType::InertialSensorStateEnumType::OFF), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ON",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::InertialSensorStateEnumType::InertialSensorStateEnumType::ON), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RESTARTING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::InertialSensorStateEnumType::InertialSensorStateEnumType::RESTARTING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode InertialSensorStateEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::InertialSensorStateEnumType::InertialSensorStateEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        InertialSensorStateEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for InertialSensorStateEnumType*/

                if (is_initialized) {
                    return &InertialSensorStateEnumType_g_tc;
                }

                InertialSensorStateEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                InertialSensorStateEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                InertialSensorStateEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                InertialSensorStateEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                InertialSensorStateEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &InertialSensorStateEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo InertialSensorStateEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo InertialSensorStateEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &InertialSensorStateEnumType_g_sampleAccessInfo;
                }

                InertialSensorStateEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                InertialSensorStateEnumType_g_sampleAccessInfo.memberAccessInfos = 
                InertialSensorStateEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::InertialSensorStateEnumType::InertialSensorStateEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        InertialSensorStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        InertialSensorStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                InertialSensorStateEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                InertialSensorStateEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::InertialSensorStateEnumType::InertialSensorStateEnumType >;

                InertialSensorStateEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &InertialSensorStateEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin InertialSensorStateEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &InertialSensorStateEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::InertialSensorStateEnumType::InertialSensorStateEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::InertialSensorStateEnumType::InertialSensorStateEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType>::value = UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType::AUTO_DEFAULT;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member LightSensitivityEnumType_g_tc_members[7]=
                {

                    {
                        (char *)"AUTO_DEFAULT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType::AUTO_DEFAULT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ISO_100",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType::ISO_100), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ISO_1600",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType::ISO_1600), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ISO_200",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType::ISO_200), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ISO_3200",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType::ISO_3200), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ISO_400",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType::ISO_400), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ISO_800",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType::ISO_800), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode LightSensitivityEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        7, /* Number of members */
                        LightSensitivityEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for LightSensitivityEnumType*/

                if (is_initialized) {
                    return &LightSensitivityEnumType_g_tc;
                }

                LightSensitivityEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                LightSensitivityEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                LightSensitivityEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                LightSensitivityEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                LightSensitivityEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &LightSensitivityEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo LightSensitivityEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo LightSensitivityEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &LightSensitivityEnumType_g_sampleAccessInfo;
                }

                LightSensitivityEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                LightSensitivityEnumType_g_sampleAccessInfo.memberAccessInfos = 
                LightSensitivityEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        LightSensitivityEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        LightSensitivityEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                LightSensitivityEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                LightSensitivityEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType >;

                LightSensitivityEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &LightSensitivityEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin LightSensitivityEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &LightSensitivityEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::LightSensitivityEnumType::LightSensitivityEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::LostCommsStatusEnumType::LostCommsStatusEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::LostCommsStatusEnumType::LostCommsStatusEnumType>::value = UMAA::Common::MaritimeEnumeration::LostCommsStatusEnumType::LostCommsStatusEnumType::ACTIVE;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::LostCommsStatusEnumType::LostCommsStatusEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member LostCommsStatusEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"ACTIVE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::LostCommsStatusEnumType::LostCommsStatusEnumType::ACTIVE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DISABLED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::LostCommsStatusEnumType::LostCommsStatusEnumType::DISABLED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ENABLED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::LostCommsStatusEnumType::LostCommsStatusEnumType::ENABLED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode LostCommsStatusEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::LostCommsStatusEnumType::LostCommsStatusEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        LostCommsStatusEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for LostCommsStatusEnumType*/

                if (is_initialized) {
                    return &LostCommsStatusEnumType_g_tc;
                }

                LostCommsStatusEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                LostCommsStatusEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                LostCommsStatusEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                LostCommsStatusEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                LostCommsStatusEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &LostCommsStatusEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo LostCommsStatusEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo LostCommsStatusEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &LostCommsStatusEnumType_g_sampleAccessInfo;
                }

                LostCommsStatusEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                LostCommsStatusEnumType_g_sampleAccessInfo.memberAccessInfos = 
                LostCommsStatusEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::LostCommsStatusEnumType::LostCommsStatusEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        LostCommsStatusEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        LostCommsStatusEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                LostCommsStatusEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                LostCommsStatusEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::LostCommsStatusEnumType::LostCommsStatusEnumType >;

                LostCommsStatusEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &LostCommsStatusEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin LostCommsStatusEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &LostCommsStatusEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::LostCommsStatusEnumType::LostCommsStatusEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::LostCommsStatusEnumType::LostCommsStatusEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::MastActionEnumType::MastActionEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::MastActionEnumType::MastActionEnumType>::value = UMAA::Common::MaritimeEnumeration::MastActionEnumType::MastActionEnumType::LOWER;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::MastActionEnumType::MastActionEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member MastActionEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"LOWER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MastActionEnumType::MastActionEnumType::LOWER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RAISE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MastActionEnumType::MastActionEnumType::RAISE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"STOP",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MastActionEnumType::MastActionEnumType::STOP), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode MastActionEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::MastActionEnumType::MastActionEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        MastActionEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for MastActionEnumType*/

                if (is_initialized) {
                    return &MastActionEnumType_g_tc;
                }

                MastActionEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                MastActionEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                MastActionEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                MastActionEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                MastActionEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &MastActionEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo MastActionEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo MastActionEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &MastActionEnumType_g_sampleAccessInfo;
                }

                MastActionEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                MastActionEnumType_g_sampleAccessInfo.memberAccessInfos = 
                MastActionEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::MastActionEnumType::MastActionEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        MastActionEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        MastActionEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                MastActionEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                MastActionEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::MastActionEnumType::MastActionEnumType >;

                MastActionEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &MastActionEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin MastActionEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &MastActionEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::MastActionEnumType::MastActionEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::MastActionEnumType::MastActionEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::MastStateEnumType::MastStateEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::MastStateEnumType::MastStateEnumType>::value = UMAA::Common::MaritimeEnumeration::MastStateEnumType::MastStateEnumType::DOWN;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::MastStateEnumType::MastStateEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member MastStateEnumType_g_tc_members[4]=
                {

                    {
                        (char *)"DOWN",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MastStateEnumType::MastStateEnumType::DOWN), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MOVING_DOWN",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MastStateEnumType::MastStateEnumType::MOVING_DOWN), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MOVING_UP",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MastStateEnumType::MastStateEnumType::MOVING_UP), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"UP",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MastStateEnumType::MastStateEnumType::UP), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode MastStateEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::MastStateEnumType::MastStateEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        4, /* Number of members */
                        MastStateEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for MastStateEnumType*/

                if (is_initialized) {
                    return &MastStateEnumType_g_tc;
                }

                MastStateEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                MastStateEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                MastStateEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                MastStateEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                MastStateEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &MastStateEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo MastStateEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo MastStateEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &MastStateEnumType_g_sampleAccessInfo;
                }

                MastStateEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                MastStateEnumType_g_sampleAccessInfo.memberAccessInfos = 
                MastStateEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::MastStateEnumType::MastStateEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        MastStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        MastStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                MastStateEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                MastStateEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::MastStateEnumType::MastStateEnumType >;

                MastStateEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &MastStateEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin MastStateEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &MastStateEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::MastStateEnumType::MastStateEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::MastStateEnumType::MastStateEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::CommandStatusEnumType::CommandStatusEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::CommandStatusEnumType::CommandStatusEnumType>::value = UMAA::Common::MaritimeEnumeration::CommandStatusEnumType::CommandStatusEnumType::FAILED;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::CommandStatusEnumType::CommandStatusEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member CommandStatusEnumType_g_tc_members[6]=
                {

                    {
                        (char *)"FAILED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CommandStatusEnumType::CommandStatusEnumType::FAILED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"COMPLETED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CommandStatusEnumType::CommandStatusEnumType::COMPLETED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ISSUED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CommandStatusEnumType::CommandStatusEnumType::ISSUED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"COMMANDED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CommandStatusEnumType::CommandStatusEnumType::COMMANDED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"EXECUTING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CommandStatusEnumType::CommandStatusEnumType::EXECUTING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CANCELED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::CommandStatusEnumType::CommandStatusEnumType::CANCELED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode CommandStatusEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::CommandStatusEnumType::CommandStatusEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        6, /* Number of members */
                        CommandStatusEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for CommandStatusEnumType*/

                if (is_initialized) {
                    return &CommandStatusEnumType_g_tc;
                }

                CommandStatusEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                CommandStatusEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                CommandStatusEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                CommandStatusEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                CommandStatusEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &CommandStatusEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo CommandStatusEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo CommandStatusEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &CommandStatusEnumType_g_sampleAccessInfo;
                }

                CommandStatusEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                CommandStatusEnumType_g_sampleAccessInfo.memberAccessInfos = 
                CommandStatusEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::CommandStatusEnumType::CommandStatusEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        CommandStatusEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        CommandStatusEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                CommandStatusEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                CommandStatusEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::CommandStatusEnumType::CommandStatusEnumType >;

                CommandStatusEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &CommandStatusEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin CommandStatusEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &CommandStatusEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::CommandStatusEnumType::CommandStatusEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::CommandStatusEnumType::CommandStatusEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType>::value = UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType::AVI;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member DataEncodingEnumType_g_tc_members[11]=
                {

                    {
                        (char *)"AVI",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType::AVI), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"H_261",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType::H_261), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"H_262",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType::H_262), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"H_263",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType::H_263), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"H_263PLUS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType::H_263PLUS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"H_264",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType::H_264), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MJPEG",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType::MJPEG), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MPEG_1",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType::MPEG_1), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MPEG_2",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType::MPEG_2), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MPEG_4",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType::MPEG_4), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NONE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType::NONE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode DataEncodingEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        11, /* Number of members */
                        DataEncodingEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for DataEncodingEnumType*/

                if (is_initialized) {
                    return &DataEncodingEnumType_g_tc;
                }

                DataEncodingEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                DataEncodingEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                DataEncodingEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                DataEncodingEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                DataEncodingEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &DataEncodingEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo DataEncodingEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo DataEncodingEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &DataEncodingEnumType_g_sampleAccessInfo;
                }

                DataEncodingEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                DataEncodingEnumType_g_sampleAccessInfo.memberAccessInfos = 
                DataEncodingEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        DataEncodingEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        DataEncodingEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                DataEncodingEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                DataEncodingEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType >;

                DataEncodingEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &DataEncodingEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin DataEncodingEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &DataEncodingEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::DataEncodingEnumType::DataEncodingEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::FeatureKindEnumType::FeatureKindEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::FeatureKindEnumType::FeatureKindEnumType>::value = UMAA::Common::MaritimeEnumeration::FeatureKindEnumType::FeatureKindEnumType::CONTACT;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::FeatureKindEnumType::FeatureKindEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member FeatureKindEnumType_g_tc_members[2]=
                {

                    {
                        (char *)"CONTACT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FeatureKindEnumType::FeatureKindEnumType::CONTACT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"OTHER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::FeatureKindEnumType::FeatureKindEnumType::OTHER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode FeatureKindEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::FeatureKindEnumType::FeatureKindEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        2, /* Number of members */
                        FeatureKindEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for FeatureKindEnumType*/

                if (is_initialized) {
                    return &FeatureKindEnumType_g_tc;
                }

                FeatureKindEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                FeatureKindEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                FeatureKindEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                FeatureKindEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                FeatureKindEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &FeatureKindEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo FeatureKindEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo FeatureKindEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &FeatureKindEnumType_g_sampleAccessInfo;
                }

                FeatureKindEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                FeatureKindEnumType_g_sampleAccessInfo.memberAccessInfos = 
                FeatureKindEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::FeatureKindEnumType::FeatureKindEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        FeatureKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        FeatureKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                FeatureKindEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                FeatureKindEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::FeatureKindEnumType::FeatureKindEnumType >;

                FeatureKindEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &FeatureKindEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin FeatureKindEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &FeatureKindEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::FeatureKindEnumType::FeatureKindEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::FeatureKindEnumType::FeatureKindEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::LoiterKindEnumType::LoiterKindEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::LoiterKindEnumType::LoiterKindEnumType>::value = UMAA::Common::MaritimeEnumeration::LoiterKindEnumType::LoiterKindEnumType::CIRCLE;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::LoiterKindEnumType::LoiterKindEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member LoiterKindEnumType_g_tc_members[2]=
                {

                    {
                        (char *)"CIRCLE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::LoiterKindEnumType::LoiterKindEnumType::CIRCLE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RACETRACK",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::LoiterKindEnumType::LoiterKindEnumType::RACETRACK), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode LoiterKindEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::LoiterKindEnumType::LoiterKindEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        2, /* Number of members */
                        LoiterKindEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for LoiterKindEnumType*/

                if (is_initialized) {
                    return &LoiterKindEnumType_g_tc;
                }

                LoiterKindEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                LoiterKindEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                LoiterKindEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                LoiterKindEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                LoiterKindEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &LoiterKindEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo LoiterKindEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo LoiterKindEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &LoiterKindEnumType_g_sampleAccessInfo;
                }

                LoiterKindEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                LoiterKindEnumType_g_sampleAccessInfo.memberAccessInfos = 
                LoiterKindEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::LoiterKindEnumType::LoiterKindEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        LoiterKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        LoiterKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                LoiterKindEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                LoiterKindEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::LoiterKindEnumType::LoiterKindEnumType >;

                LoiterKindEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &LoiterKindEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin LoiterKindEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &LoiterKindEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::LoiterKindEnumType::LoiterKindEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::LoiterKindEnumType::LoiterKindEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType>::value = UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::PLANNED_PENDING_APPROVAL;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member TaskStateEnumType_g_tc_members[18]=
                {

                    {
                        (char *)"PLANNED_PENDING_APPROVAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::PLANNED_PENDING_APPROVAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"AWAITING_EXECUTION_APPROVAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::AWAITING_EXECUTION_APPROVAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ALLOCATED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::ALLOCATED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"EXECUTION_APPROVED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::EXECUTION_APPROVED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CANCELED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::CANCELED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"COMPLETED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::COMPLETED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DROPPED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::DROPPED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PLANNED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::PLANNED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PROPOSED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::PROPOSED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"QUEUED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::QUEUED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"EXECUTING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::EXECUTING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FAILED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::FAILED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"UNALLOCATED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::UNALLOCATED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ALLOCATED_PENDING_APPROVAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::ALLOCATED_PENDING_APPROVAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"AWAITING_MISSION_PLAN",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::AWAITING_MISSION_PLAN), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PAUSED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::PAUSED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"QUEUING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::QUEUING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PLANNING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType::PLANNING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode TaskStateEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        18, /* Number of members */
                        TaskStateEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for TaskStateEnumType*/

                if (is_initialized) {
                    return &TaskStateEnumType_g_tc;
                }

                TaskStateEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                TaskStateEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                TaskStateEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                TaskStateEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                TaskStateEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &TaskStateEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo TaskStateEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo TaskStateEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &TaskStateEnumType_g_sampleAccessInfo;
                }

                TaskStateEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                TaskStateEnumType_g_sampleAccessInfo.memberAccessInfos = 
                TaskStateEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        TaskStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        TaskStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                TaskStateEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                TaskStateEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType >;

                TaskStateEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &TaskStateEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin TaskStateEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &TaskStateEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::TaskStateEnumType::TaskStateEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::TransportEncodingEnumType::TransportEncodingEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::TransportEncodingEnumType::TransportEncodingEnumType>::value = UMAA::Common::MaritimeEnumeration::TransportEncodingEnumType::TransportEncodingEnumType::MPEG_2;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::TransportEncodingEnumType::TransportEncodingEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member TransportEncodingEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"MPEG_2",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TransportEncodingEnumType::TransportEncodingEnumType::MPEG_2), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MP4",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TransportEncodingEnumType::TransportEncodingEnumType::MP4), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"OTHER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TransportEncodingEnumType::TransportEncodingEnumType::OTHER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode TransportEncodingEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::TransportEncodingEnumType::TransportEncodingEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        TransportEncodingEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for TransportEncodingEnumType*/

                if (is_initialized) {
                    return &TransportEncodingEnumType_g_tc;
                }

                TransportEncodingEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                TransportEncodingEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                TransportEncodingEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                TransportEncodingEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                TransportEncodingEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &TransportEncodingEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo TransportEncodingEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo TransportEncodingEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &TransportEncodingEnumType_g_sampleAccessInfo;
                }

                TransportEncodingEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                TransportEncodingEnumType_g_sampleAccessInfo.memberAccessInfos = 
                TransportEncodingEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::TransportEncodingEnumType::TransportEncodingEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        TransportEncodingEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        TransportEncodingEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                TransportEncodingEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                TransportEncodingEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::TransportEncodingEnumType::TransportEncodingEnumType >;

                TransportEncodingEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &TransportEncodingEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin TransportEncodingEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &TransportEncodingEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::TransportEncodingEnumType::TransportEncodingEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::TransportEncodingEnumType::TransportEncodingEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType>::value = UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType::APPROACH_FINAL_POINT;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member WaypointKindEnumType_g_tc_members[9]=
                {

                    {
                        (char *)"APPROACH_FINAL_POINT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType::APPROACH_FINAL_POINT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"APPROACH_INITIAL_POINT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType::APPROACH_INITIAL_POINT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LAUNCH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType::LAUNCH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LOITER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType::LOITER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NAV_ONLY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType::NAV_ONLY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NAV_TARGET",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType::NAV_TARGET), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"OTHER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType::OTHER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RECOVERY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType::RECOVERY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RENDEZVOUS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType::RENDEZVOUS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode WaypointKindEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        9, /* Number of members */
                        WaypointKindEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for WaypointKindEnumType*/

                if (is_initialized) {
                    return &WaypointKindEnumType_g_tc;
                }

                WaypointKindEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                WaypointKindEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                WaypointKindEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                WaypointKindEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                WaypointKindEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &WaypointKindEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo WaypointKindEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo WaypointKindEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &WaypointKindEnumType_g_sampleAccessInfo;
                }

                WaypointKindEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                WaypointKindEnumType_g_sampleAccessInfo.memberAccessInfos = 
                WaypointKindEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        WaypointKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        WaypointKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                WaypointKindEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                WaypointKindEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType >;

                WaypointKindEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &WaypointKindEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin WaypointKindEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &WaypointKindEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::WaypointKindEnumType::WaypointKindEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::MeteringModeEnumType::MeteringModeEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::MeteringModeEnumType::MeteringModeEnumType>::value = UMAA::Common::MaritimeEnumeration::MeteringModeEnumType::MeteringModeEnumType::AUTO_DEFAULT;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::MeteringModeEnumType::MeteringModeEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member MeteringModeEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"AUTO_DEFAULT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MeteringModeEnumType::MeteringModeEnumType::AUTO_DEFAULT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CENTER_WEIGHTED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MeteringModeEnumType::MeteringModeEnumType::CENTER_WEIGHTED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SPOT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MeteringModeEnumType::MeteringModeEnumType::SPOT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode MeteringModeEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::MeteringModeEnumType::MeteringModeEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        MeteringModeEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for MeteringModeEnumType*/

                if (is_initialized) {
                    return &MeteringModeEnumType_g_tc;
                }

                MeteringModeEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                MeteringModeEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                MeteringModeEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                MeteringModeEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                MeteringModeEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &MeteringModeEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo MeteringModeEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo MeteringModeEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &MeteringModeEnumType_g_sampleAccessInfo;
                }

                MeteringModeEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                MeteringModeEnumType_g_sampleAccessInfo.memberAccessInfos = 
                MeteringModeEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::MeteringModeEnumType::MeteringModeEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        MeteringModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        MeteringModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                MeteringModeEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                MeteringModeEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::MeteringModeEnumType::MeteringModeEnumType >;

                MeteringModeEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &MeteringModeEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin MeteringModeEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &MeteringModeEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::MeteringModeEnumType::MeteringModeEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::MeteringModeEnumType::MeteringModeEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType>::value = UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType::_FIXED;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member MountModeEnumType_g_tc_members[7]=
                {

                    {
                        (char *)"_FIXED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType::_FIXED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FIXED_BOW_THRUSTER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType::FIXED_BOW_THRUSTER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FIXED_PORT_PROPULSOR",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType::FIXED_PORT_PROPULSOR), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FIXED_STERN_THRUSTER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType::FIXED_STERN_THRUSTER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"VARIABLE_BEARING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType::VARIABLE_BEARING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"VARIABLE_PITCH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType::VARIABLE_PITCH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"VARIABLE_PITCH_AND_BEARING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType::VARIABLE_PITCH_AND_BEARING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode MountModeEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        7, /* Number of members */
                        MountModeEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for MountModeEnumType*/

                if (is_initialized) {
                    return &MountModeEnumType_g_tc;
                }

                MountModeEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                MountModeEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                MountModeEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                MountModeEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                MountModeEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &MountModeEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo MountModeEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo MountModeEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &MountModeEnumType_g_sampleAccessInfo;
                }

                MountModeEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                MountModeEnumType_g_sampleAccessInfo.memberAccessInfos = 
                MountModeEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        MountModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        MountModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                MountModeEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                MountModeEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType >;

                MountModeEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &MountModeEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin MountModeEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &MountModeEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::MountModeEnumType::MountModeEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::NavigationSolutionEnumType::NavigationSolutionEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::NavigationSolutionEnumType::NavigationSolutionEnumType>::value = UMAA::Common::MaritimeEnumeration::NavigationSolutionEnumType::NavigationSolutionEnumType::ESTIMATED;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::NavigationSolutionEnumType::NavigationSolutionEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member NavigationSolutionEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"ESTIMATED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::NavigationSolutionEnumType::NavigationSolutionEnumType::ESTIMATED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GROUND_TRUTH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::NavigationSolutionEnumType::NavigationSolutionEnumType::GROUND_TRUTH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MEASURED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::NavigationSolutionEnumType::NavigationSolutionEnumType::MEASURED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode NavigationSolutionEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::NavigationSolutionEnumType::NavigationSolutionEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        NavigationSolutionEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for NavigationSolutionEnumType*/

                if (is_initialized) {
                    return &NavigationSolutionEnumType_g_tc;
                }

                NavigationSolutionEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                NavigationSolutionEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                NavigationSolutionEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                NavigationSolutionEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                NavigationSolutionEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &NavigationSolutionEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo NavigationSolutionEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo NavigationSolutionEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &NavigationSolutionEnumType_g_sampleAccessInfo;
                }

                NavigationSolutionEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                NavigationSolutionEnumType_g_sampleAccessInfo.memberAccessInfos = 
                NavigationSolutionEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::NavigationSolutionEnumType::NavigationSolutionEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        NavigationSolutionEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        NavigationSolutionEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                NavigationSolutionEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                NavigationSolutionEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::NavigationSolutionEnumType::NavigationSolutionEnumType >;

                NavigationSolutionEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &NavigationSolutionEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin NavigationSolutionEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &NavigationSolutionEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::NavigationSolutionEnumType::NavigationSolutionEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::NavigationSolutionEnumType::NavigationSolutionEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::ObstacleAvoidanceEnumType::ObstacleAvoidanceEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::ObstacleAvoidanceEnumType::ObstacleAvoidanceEnumType>::value = UMAA::Common::MaritimeEnumeration::ObstacleAvoidanceEnumType::ObstacleAvoidanceEnumType::DEVIATE_FROM_PATH;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::ObstacleAvoidanceEnumType::ObstacleAvoidanceEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member ObstacleAvoidanceEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"DEVIATE_FROM_PATH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ObstacleAvoidanceEnumType::ObstacleAvoidanceEnumType::DEVIATE_FROM_PATH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DO_NOTHING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ObstacleAvoidanceEnumType::ObstacleAvoidanceEnumType::DO_NOTHING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"STOP_ON_PATH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ObstacleAvoidanceEnumType::ObstacleAvoidanceEnumType::STOP_ON_PATH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode ObstacleAvoidanceEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::ObstacleAvoidanceEnumType::ObstacleAvoidanceEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        ObstacleAvoidanceEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for ObstacleAvoidanceEnumType*/

                if (is_initialized) {
                    return &ObstacleAvoidanceEnumType_g_tc;
                }

                ObstacleAvoidanceEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                ObstacleAvoidanceEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                ObstacleAvoidanceEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                ObstacleAvoidanceEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                ObstacleAvoidanceEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &ObstacleAvoidanceEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo ObstacleAvoidanceEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo ObstacleAvoidanceEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &ObstacleAvoidanceEnumType_g_sampleAccessInfo;
                }

                ObstacleAvoidanceEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                ObstacleAvoidanceEnumType_g_sampleAccessInfo.memberAccessInfos = 
                ObstacleAvoidanceEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::ObstacleAvoidanceEnumType::ObstacleAvoidanceEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        ObstacleAvoidanceEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        ObstacleAvoidanceEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                ObstacleAvoidanceEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                ObstacleAvoidanceEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::ObstacleAvoidanceEnumType::ObstacleAvoidanceEnumType >;

                ObstacleAvoidanceEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &ObstacleAvoidanceEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin ObstacleAvoidanceEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &ObstacleAvoidanceEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::ObstacleAvoidanceEnumType::ObstacleAvoidanceEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::ObstacleAvoidanceEnumType::ObstacleAvoidanceEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::PathWayEnumType::PathWayEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::PathWayEnumType::PathWayEnumType>::value = UMAA::Common::MaritimeEnumeration::PathWayEnumType::PathWayEnumType::HISTORIAL_GLOBAL;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::PathWayEnumType::PathWayEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member PathWayEnumType_g_tc_members[4]=
                {

                    {
                        (char *)"HISTORIAL_GLOBAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PathWayEnumType::PathWayEnumType::HISTORIAL_GLOBAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"HISTORICAL_LOCAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PathWayEnumType::PathWayEnumType::HISTORICAL_LOCAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PLANNED_GLOBAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PathWayEnumType::PathWayEnumType::PLANNED_GLOBAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PLANNED_LOCAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PathWayEnumType::PathWayEnumType::PLANNED_LOCAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode PathWayEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::PathWayEnumType::PathWayEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        4, /* Number of members */
                        PathWayEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for PathWayEnumType*/

                if (is_initialized) {
                    return &PathWayEnumType_g_tc;
                }

                PathWayEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                PathWayEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                PathWayEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                PathWayEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                PathWayEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &PathWayEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo PathWayEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo PathWayEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &PathWayEnumType_g_sampleAccessInfo;
                }

                PathWayEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                PathWayEnumType_g_sampleAccessInfo.memberAccessInfos = 
                PathWayEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::PathWayEnumType::PathWayEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        PathWayEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        PathWayEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                PathWayEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                PathWayEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::PathWayEnumType::PathWayEnumType >;

                PathWayEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &PathWayEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin PathWayEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &PathWayEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::PathWayEnumType::PathWayEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::PathWayEnumType::PathWayEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::PlatformModeEnumType::PlatformModeEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::PlatformModeEnumType::PlatformModeEnumType>::value = UMAA::Common::MaritimeEnumeration::PlatformModeEnumType::PlatformModeEnumType::MAINTENANCE;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::PlatformModeEnumType::PlatformModeEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member PlatformModeEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"MAINTENANCE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PlatformModeEnumType::PlatformModeEnumType::MAINTENANCE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"STANDARD_OPERATING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PlatformModeEnumType::PlatformModeEnumType::STANDARD_OPERATING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"TRAINING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PlatformModeEnumType::PlatformModeEnumType::TRAINING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode PlatformModeEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::PlatformModeEnumType::PlatformModeEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        PlatformModeEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for PlatformModeEnumType*/

                if (is_initialized) {
                    return &PlatformModeEnumType_g_tc;
                }

                PlatformModeEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                PlatformModeEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                PlatformModeEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                PlatformModeEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                PlatformModeEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &PlatformModeEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo PlatformModeEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo PlatformModeEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &PlatformModeEnumType_g_sampleAccessInfo;
                }

                PlatformModeEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                PlatformModeEnumType_g_sampleAccessInfo.memberAccessInfos = 
                PlatformModeEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::PlatformModeEnumType::PlatformModeEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        PlatformModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        PlatformModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                PlatformModeEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                PlatformModeEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::PlatformModeEnumType::PlatformModeEnumType >;

                PlatformModeEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &PlatformModeEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin PlatformModeEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &PlatformModeEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::PlatformModeEnumType::PlatformModeEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::PlatformModeEnumType::PlatformModeEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::PlatformModeTransitionEnumType::PlatformModeTransitionEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::PlatformModeTransitionEnumType::PlatformModeTransitionEnumType>::value = UMAA::Common::MaritimeEnumeration::PlatformModeTransitionEnumType::PlatformModeTransitionEnumType::ACTIVE;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::PlatformModeTransitionEnumType::PlatformModeTransitionEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member PlatformModeTransitionEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"ACTIVE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PlatformModeTransitionEnumType::PlatformModeTransitionEnumType::ACTIVE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"EXITING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PlatformModeTransitionEnumType::PlatformModeTransitionEnumType::EXITING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INITIALIZING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PlatformModeTransitionEnumType::PlatformModeTransitionEnumType::INITIALIZING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode PlatformModeTransitionEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::PlatformModeTransitionEnumType::PlatformModeTransitionEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        PlatformModeTransitionEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for PlatformModeTransitionEnumType*/

                if (is_initialized) {
                    return &PlatformModeTransitionEnumType_g_tc;
                }

                PlatformModeTransitionEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                PlatformModeTransitionEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                PlatformModeTransitionEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                PlatformModeTransitionEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                PlatformModeTransitionEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &PlatformModeTransitionEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo PlatformModeTransitionEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo PlatformModeTransitionEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &PlatformModeTransitionEnumType_g_sampleAccessInfo;
                }

                PlatformModeTransitionEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                PlatformModeTransitionEnumType_g_sampleAccessInfo.memberAccessInfos = 
                PlatformModeTransitionEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::PlatformModeTransitionEnumType::PlatformModeTransitionEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        PlatformModeTransitionEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        PlatformModeTransitionEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                PlatformModeTransitionEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                PlatformModeTransitionEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::PlatformModeTransitionEnumType::PlatformModeTransitionEnumType >;

                PlatformModeTransitionEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &PlatformModeTransitionEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin PlatformModeTransitionEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &PlatformModeTransitionEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::PlatformModeTransitionEnumType::PlatformModeTransitionEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::PlatformModeTransitionEnumType::PlatformModeTransitionEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::PowerPlantStateEnumType::PowerPlantStateEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::PowerPlantStateEnumType::PowerPlantStateEnumType>::value = UMAA::Common::MaritimeEnumeration::PowerPlantStateEnumType::PowerPlantStateEnumType::FAULT;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::PowerPlantStateEnumType::PowerPlantStateEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member PowerPlantStateEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"FAULT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PowerPlantStateEnumType::PowerPlantStateEnumType::FAULT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"OFF",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PowerPlantStateEnumType::PowerPlantStateEnumType::OFF), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ON",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PowerPlantStateEnumType::PowerPlantStateEnumType::ON), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode PowerPlantStateEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::PowerPlantStateEnumType::PowerPlantStateEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        PowerPlantStateEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for PowerPlantStateEnumType*/

                if (is_initialized) {
                    return &PowerPlantStateEnumType_g_tc;
                }

                PowerPlantStateEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                PowerPlantStateEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                PowerPlantStateEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                PowerPlantStateEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                PowerPlantStateEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &PowerPlantStateEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo PowerPlantStateEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo PowerPlantStateEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &PowerPlantStateEnumType_g_sampleAccessInfo;
                }

                PowerPlantStateEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                PowerPlantStateEnumType_g_sampleAccessInfo.memberAccessInfos = 
                PowerPlantStateEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::PowerPlantStateEnumType::PowerPlantStateEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        PowerPlantStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        PowerPlantStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                PowerPlantStateEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                PowerPlantStateEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::PowerPlantStateEnumType::PowerPlantStateEnumType >;

                PowerPlantStateEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &PowerPlantStateEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin PowerPlantStateEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &PowerPlantStateEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::PowerPlantStateEnumType::PowerPlantStateEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::PowerPlantStateEnumType::PowerPlantStateEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::PumpStateEnumType::PumpStateEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::PumpStateEnumType::PumpStateEnumType>::value = UMAA::Common::MaritimeEnumeration::PumpStateEnumType::PumpStateEnumType::FAULT;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::PumpStateEnumType::PumpStateEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member PumpStateEnumType_g_tc_members[4]=
                {

                    {
                        (char *)"FAULT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PumpStateEnumType::PumpStateEnumType::FAULT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"OFF",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PumpStateEnumType::PumpStateEnumType::OFF), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ON_FORWARD",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PumpStateEnumType::PumpStateEnumType::ON_FORWARD), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ON_REVERSE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::PumpStateEnumType::PumpStateEnumType::ON_REVERSE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode PumpStateEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::PumpStateEnumType::PumpStateEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        4, /* Number of members */
                        PumpStateEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for PumpStateEnumType*/

                if (is_initialized) {
                    return &PumpStateEnumType_g_tc;
                }

                PumpStateEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                PumpStateEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                PumpStateEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                PumpStateEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                PumpStateEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &PumpStateEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo PumpStateEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo PumpStateEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &PumpStateEnumType_g_sampleAccessInfo;
                }

                PumpStateEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                PumpStateEnumType_g_sampleAccessInfo.memberAccessInfos = 
                PumpStateEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::PumpStateEnumType::PumpStateEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        PumpStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        PumpStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                PumpStateEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                PumpStateEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::PumpStateEnumType::PumpStateEnumType >;

                PumpStateEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &PumpStateEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin PumpStateEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &PumpStateEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::PumpStateEnumType::PumpStateEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::PumpStateEnumType::PumpStateEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType>::value = UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType::INVALID_HORIZONTAL_FOV;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member RangeErrorCodeEnumType_g_tc_members[8]=
                {

                    {
                        (char *)"INVALID_HORIZONTAL_FOV",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType::INVALID_HORIZONTAL_FOV), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INVALID_SENSOR_RANGE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType::INVALID_SENSOR_RANGE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INVALID_SENSOR_STATE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType::INVALID_SENSOR_STATE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INVALID_UPDATE_RATE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType::INVALID_UPDATE_RATE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INVALID_VERTICAL_FOV",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType::INVALID_VERTICAL_FOV), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MULTIPLE_INVALID_PARAMETERS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType::MULTIPLE_INVALID_PARAMETERS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"UNKNOWN_ERROR_FAULT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType::UNKNOWN_ERROR_FAULT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"UNKNOWN_SENSOR_ID",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType::UNKNOWN_SENSOR_ID), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode RangeErrorCodeEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        8, /* Number of members */
                        RangeErrorCodeEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for RangeErrorCodeEnumType*/

                if (is_initialized) {
                    return &RangeErrorCodeEnumType_g_tc;
                }

                RangeErrorCodeEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                RangeErrorCodeEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                RangeErrorCodeEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                RangeErrorCodeEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                RangeErrorCodeEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &RangeErrorCodeEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo RangeErrorCodeEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo RangeErrorCodeEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &RangeErrorCodeEnumType_g_sampleAccessInfo;
                }

                RangeErrorCodeEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                RangeErrorCodeEnumType_g_sampleAccessInfo.memberAccessInfos = 
                RangeErrorCodeEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        RangeErrorCodeEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        RangeErrorCodeEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                RangeErrorCodeEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                RangeErrorCodeEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType >;

                RangeErrorCodeEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &RangeErrorCodeEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin RangeErrorCodeEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &RangeErrorCodeEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::RangeErrorCodeEnumType::RangeErrorCodeEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::RenderUselessStateEnumType::RenderUselessStateEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::RenderUselessStateEnumType::RenderUselessStateEnumType>::value = UMAA::Common::MaritimeEnumeration::RenderUselessStateEnumType::RenderUselessStateEnumType::NORMAL;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::RenderUselessStateEnumType::RenderUselessStateEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member RenderUselessStateEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"NORMAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::RenderUselessStateEnumType::RenderUselessStateEnumType::NORMAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RENDERED_USELESS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::RenderUselessStateEnumType::RenderUselessStateEnumType::RENDERED_USELESS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RENDERED_USELESS_FAILED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::RenderUselessStateEnumType::RenderUselessStateEnumType::RENDERED_USELESS_FAILED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode RenderUselessStateEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::RenderUselessStateEnumType::RenderUselessStateEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        RenderUselessStateEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for RenderUselessStateEnumType*/

                if (is_initialized) {
                    return &RenderUselessStateEnumType_g_tc;
                }

                RenderUselessStateEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                RenderUselessStateEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                RenderUselessStateEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                RenderUselessStateEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                RenderUselessStateEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &RenderUselessStateEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo RenderUselessStateEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo RenderUselessStateEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &RenderUselessStateEnumType_g_sampleAccessInfo;
                }

                RenderUselessStateEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                RenderUselessStateEnumType_g_sampleAccessInfo.memberAccessInfos = 
                RenderUselessStateEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::RenderUselessStateEnumType::RenderUselessStateEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        RenderUselessStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        RenderUselessStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                RenderUselessStateEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                RenderUselessStateEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::RenderUselessStateEnumType::RenderUselessStateEnumType >;

                RenderUselessStateEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &RenderUselessStateEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin RenderUselessStateEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &RenderUselessStateEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::RenderUselessStateEnumType::RenderUselessStateEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::RenderUselessStateEnumType::RenderUselessStateEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::SourceIndicatorEnumType::SourceIndicatorEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::SourceIndicatorEnumType::SourceIndicatorEnumType>::value = UMAA::Common::MaritimeEnumeration::SourceIndicatorEnumType::SourceIndicatorEnumType::ACTUAL;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::SourceIndicatorEnumType::SourceIndicatorEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member SourceIndicatorEnumType_g_tc_members[4]=
                {

                    {
                        (char *)"ACTUAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::SourceIndicatorEnumType::SourceIndicatorEnumType::ACTUAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"GROUND_TRUTH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::SourceIndicatorEnumType::SourceIndicatorEnumType::GROUND_TRUTH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SIMULATED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::SourceIndicatorEnumType::SourceIndicatorEnumType::SIMULATED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"TENTATIVE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::SourceIndicatorEnumType::SourceIndicatorEnumType::TENTATIVE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode SourceIndicatorEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::SourceIndicatorEnumType::SourceIndicatorEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        4, /* Number of members */
                        SourceIndicatorEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for SourceIndicatorEnumType*/

                if (is_initialized) {
                    return &SourceIndicatorEnumType_g_tc;
                }

                SourceIndicatorEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                SourceIndicatorEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                SourceIndicatorEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                SourceIndicatorEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                SourceIndicatorEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &SourceIndicatorEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo SourceIndicatorEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo SourceIndicatorEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &SourceIndicatorEnumType_g_sampleAccessInfo;
                }

                SourceIndicatorEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                SourceIndicatorEnumType_g_sampleAccessInfo.memberAccessInfos = 
                SourceIndicatorEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::SourceIndicatorEnumType::SourceIndicatorEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        SourceIndicatorEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        SourceIndicatorEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                SourceIndicatorEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                SourceIndicatorEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::SourceIndicatorEnumType::SourceIndicatorEnumType >;

                SourceIndicatorEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &SourceIndicatorEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin SourceIndicatorEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &SourceIndicatorEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::SourceIndicatorEnumType::SourceIndicatorEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::SourceIndicatorEnumType::SourceIndicatorEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::StillImageErrorCodeEnumType::StillImageErrorCodeEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::StillImageErrorCodeEnumType::StillImageErrorCodeEnumType>::value = UMAA::Common::MaritimeEnumeration::StillImageErrorCodeEnumType::StillImageErrorCodeEnumType::INVALID_FORMAT;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::StillImageErrorCodeEnumType::StillImageErrorCodeEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member StillImageErrorCodeEnumType_g_tc_members[5]=
                {

                    {
                        (char *)"INVALID_FORMAT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::StillImageErrorCodeEnumType::StillImageErrorCodeEnumType::INVALID_FORMAT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INVALID_FRAME_SIZE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::StillImageErrorCodeEnumType::StillImageErrorCodeEnumType::INVALID_FRAME_SIZE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MULTIPLE_INVALID_PARAMETERS",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::StillImageErrorCodeEnumType::StillImageErrorCodeEnumType::MULTIPLE_INVALID_PARAMETERS), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"UNKNOWN_ERROR_FAULT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::StillImageErrorCodeEnumType::StillImageErrorCodeEnumType::UNKNOWN_ERROR_FAULT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"UNKNOWN_SENSOR_ID",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::StillImageErrorCodeEnumType::StillImageErrorCodeEnumType::UNKNOWN_SENSOR_ID), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode StillImageErrorCodeEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::StillImageErrorCodeEnumType::StillImageErrorCodeEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        5, /* Number of members */
                        StillImageErrorCodeEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for StillImageErrorCodeEnumType*/

                if (is_initialized) {
                    return &StillImageErrorCodeEnumType_g_tc;
                }

                StillImageErrorCodeEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                StillImageErrorCodeEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                StillImageErrorCodeEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                StillImageErrorCodeEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                StillImageErrorCodeEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &StillImageErrorCodeEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo StillImageErrorCodeEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo StillImageErrorCodeEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &StillImageErrorCodeEnumType_g_sampleAccessInfo;
                }

                StillImageErrorCodeEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                StillImageErrorCodeEnumType_g_sampleAccessInfo.memberAccessInfos = 
                StillImageErrorCodeEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::StillImageErrorCodeEnumType::StillImageErrorCodeEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        StillImageErrorCodeEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        StillImageErrorCodeEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                StillImageErrorCodeEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                StillImageErrorCodeEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::StillImageErrorCodeEnumType::StillImageErrorCodeEnumType >;

                StillImageErrorCodeEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &StillImageErrorCodeEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin StillImageErrorCodeEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &StillImageErrorCodeEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::StillImageErrorCodeEnumType::StillImageErrorCodeEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::StillImageErrorCodeEnumType::StillImageErrorCodeEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::StreamStateEnumType::StreamStateEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::StreamStateEnumType::StreamStateEnumType>::value = UMAA::Common::MaritimeEnumeration::StreamStateEnumType::StreamStateEnumType::PAUSE;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::StreamStateEnumType::StreamStateEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member StreamStateEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"PAUSE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::StreamStateEnumType::StreamStateEnumType::PAUSE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PLAY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::StreamStateEnumType::StreamStateEnumType::PLAY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"STOP",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::StreamStateEnumType::StreamStateEnumType::STOP), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode StreamStateEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::StreamStateEnumType::StreamStateEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        StreamStateEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for StreamStateEnumType*/

                if (is_initialized) {
                    return &StreamStateEnumType_g_tc;
                }

                StreamStateEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                StreamStateEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                StreamStateEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                StreamStateEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                StreamStateEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &StreamStateEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo StreamStateEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo StreamStateEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &StreamStateEnumType_g_sampleAccessInfo;
                }

                StreamStateEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                StreamStateEnumType_g_sampleAccessInfo.memberAccessInfos = 
                StreamStateEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::StreamStateEnumType::StreamStateEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        StreamStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        StreamStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                StreamStateEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                StreamStateEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::StreamStateEnumType::StreamStateEnumType >;

                StreamStateEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &StreamStateEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin StreamStateEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &StreamStateEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::StreamStateEnumType::StreamStateEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::StreamStateEnumType::StreamStateEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::TamperDetectionStateEnumType::TamperDetectionStateEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::TamperDetectionStateEnumType::TamperDetectionStateEnumType>::value = UMAA::Common::MaritimeEnumeration::TamperDetectionStateEnumType::TamperDetectionStateEnumType::ALWAYS_ENABLED_OR_CLEAR;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::TamperDetectionStateEnumType::TamperDetectionStateEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member TamperDetectionStateEnumType_g_tc_members[3]=
                {

                    {
                        (char *)"ALWAYS_ENABLED_OR_CLEAR",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TamperDetectionStateEnumType::TamperDetectionStateEnumType::ALWAYS_ENABLED_OR_CLEAR), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DISABLED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TamperDetectionStateEnumType::TamperDetectionStateEnumType::DISABLED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"ENABLED",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::TamperDetectionStateEnumType::TamperDetectionStateEnumType::ENABLED), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode TamperDetectionStateEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::TamperDetectionStateEnumType::TamperDetectionStateEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        3, /* Number of members */
                        TamperDetectionStateEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for TamperDetectionStateEnumType*/

                if (is_initialized) {
                    return &TamperDetectionStateEnumType_g_tc;
                }

                TamperDetectionStateEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                TamperDetectionStateEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                TamperDetectionStateEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                TamperDetectionStateEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                TamperDetectionStateEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &TamperDetectionStateEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo TamperDetectionStateEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo TamperDetectionStateEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &TamperDetectionStateEnumType_g_sampleAccessInfo;
                }

                TamperDetectionStateEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                TamperDetectionStateEnumType_g_sampleAccessInfo.memberAccessInfos = 
                TamperDetectionStateEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::TamperDetectionStateEnumType::TamperDetectionStateEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        TamperDetectionStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        TamperDetectionStateEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                TamperDetectionStateEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                TamperDetectionStateEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::TamperDetectionStateEnumType::TamperDetectionStateEnumType >;

                TamperDetectionStateEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &TamperDetectionStateEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin TamperDetectionStateEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &TamperDetectionStateEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::TamperDetectionStateEnumType::TamperDetectionStateEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::TamperDetectionStateEnumType::TamperDetectionStateEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::VehicleSpeedModeEnumType::VehicleSpeedModeEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::VehicleSpeedModeEnumType::VehicleSpeedModeEnumType>::value = UMAA::Common::MaritimeEnumeration::VehicleSpeedModeEnumType::VehicleSpeedModeEnumType::LRC;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::VehicleSpeedModeEnumType::VehicleSpeedModeEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member VehicleSpeedModeEnumType_g_tc_members[5]=
                {

                    {
                        (char *)"LRC",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VehicleSpeedModeEnumType::VehicleSpeedModeEnumType::LRC), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MEC",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VehicleSpeedModeEnumType::VehicleSpeedModeEnumType::MEC), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MRC",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VehicleSpeedModeEnumType::VehicleSpeedModeEnumType::MRC), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SLOW",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VehicleSpeedModeEnumType::VehicleSpeedModeEnumType::SLOW), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"VEHICLE_SPECIFIC",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VehicleSpeedModeEnumType::VehicleSpeedModeEnumType::VEHICLE_SPECIFIC), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode VehicleSpeedModeEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::VehicleSpeedModeEnumType::VehicleSpeedModeEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        5, /* Number of members */
                        VehicleSpeedModeEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for VehicleSpeedModeEnumType*/

                if (is_initialized) {
                    return &VehicleSpeedModeEnumType_g_tc;
                }

                VehicleSpeedModeEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                VehicleSpeedModeEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                VehicleSpeedModeEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                VehicleSpeedModeEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                VehicleSpeedModeEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &VehicleSpeedModeEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo VehicleSpeedModeEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo VehicleSpeedModeEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &VehicleSpeedModeEnumType_g_sampleAccessInfo;
                }

                VehicleSpeedModeEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                VehicleSpeedModeEnumType_g_sampleAccessInfo.memberAccessInfos = 
                VehicleSpeedModeEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::VehicleSpeedModeEnumType::VehicleSpeedModeEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        VehicleSpeedModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        VehicleSpeedModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                VehicleSpeedModeEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                VehicleSpeedModeEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::VehicleSpeedModeEnumType::VehicleSpeedModeEnumType >;

                VehicleSpeedModeEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &VehicleSpeedModeEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin VehicleSpeedModeEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &VehicleSpeedModeEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::VehicleSpeedModeEnumType::VehicleSpeedModeEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::VehicleSpeedModeEnumType::VehicleSpeedModeEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::VehicleSpeedReferenceEnumType::VehicleSpeedReferenceEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::VehicleSpeedReferenceEnumType::VehicleSpeedReferenceEnumType>::value = UMAA::Common::MaritimeEnumeration::VehicleSpeedReferenceEnumType::VehicleSpeedReferenceEnumType::SPEED_THROUGH_AIR;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::VehicleSpeedReferenceEnumType::VehicleSpeedReferenceEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member VehicleSpeedReferenceEnumType_g_tc_members[5]=
                {

                    {
                        (char *)"SPEED_THROUGH_AIR",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VehicleSpeedReferenceEnumType::VehicleSpeedReferenceEnumType::SPEED_THROUGH_AIR), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"OTHER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VehicleSpeedReferenceEnumType::VehicleSpeedReferenceEnumType::OTHER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RPM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VehicleSpeedReferenceEnumType::VehicleSpeedReferenceEnumType::RPM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SPEED_OVER_GROUND",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VehicleSpeedReferenceEnumType::VehicleSpeedReferenceEnumType::SPEED_OVER_GROUND), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SPEED_THROUGH_WATER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VehicleSpeedReferenceEnumType::VehicleSpeedReferenceEnumType::SPEED_THROUGH_WATER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode VehicleSpeedReferenceEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::VehicleSpeedReferenceEnumType::VehicleSpeedReferenceEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        5, /* Number of members */
                        VehicleSpeedReferenceEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for VehicleSpeedReferenceEnumType*/

                if (is_initialized) {
                    return &VehicleSpeedReferenceEnumType_g_tc;
                }

                VehicleSpeedReferenceEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                VehicleSpeedReferenceEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                VehicleSpeedReferenceEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                VehicleSpeedReferenceEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                VehicleSpeedReferenceEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &VehicleSpeedReferenceEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo VehicleSpeedReferenceEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo VehicleSpeedReferenceEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &VehicleSpeedReferenceEnumType_g_sampleAccessInfo;
                }

                VehicleSpeedReferenceEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                VehicleSpeedReferenceEnumType_g_sampleAccessInfo.memberAccessInfos = 
                VehicleSpeedReferenceEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::VehicleSpeedReferenceEnumType::VehicleSpeedReferenceEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        VehicleSpeedReferenceEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        VehicleSpeedReferenceEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                VehicleSpeedReferenceEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                VehicleSpeedReferenceEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::VehicleSpeedReferenceEnumType::VehicleSpeedReferenceEnumType >;

                VehicleSpeedReferenceEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &VehicleSpeedReferenceEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin VehicleSpeedReferenceEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &VehicleSpeedReferenceEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::VehicleSpeedReferenceEnumType::VehicleSpeedReferenceEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::VehicleSpeedReferenceEnumType::VehicleSpeedReferenceEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType>::value = UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType::CURRENT_COMMAND_SOG;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member VelocityCommandTypeEnumType_g_tc_members[8]=
                {

                    {
                        (char *)"CURRENT_COMMAND_SOG",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType::CURRENT_COMMAND_SOG), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CURRENT_COMMAND_SRM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType::CURRENT_COMMAND_SRM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DEFAULT_COMMAND_SOG",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType::DEFAULT_COMMAND_SOG), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DEFAULT_COMMAND_SRM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType::DEFAULT_COMMAND_SRM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MAX_ALLOWED_SOG",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType::MAX_ALLOWED_SOG), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MAX_ALLOWED_SRM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType::MAX_ALLOWED_SRM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MIN_ALLOWED_SOG",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType::MIN_ALLOWED_SOG), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MIN_ALLOWED_SRM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType::MIN_ALLOWED_SRM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode VelocityCommandTypeEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        8, /* Number of members */
                        VelocityCommandTypeEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for VelocityCommandTypeEnumType*/

                if (is_initialized) {
                    return &VelocityCommandTypeEnumType_g_tc;
                }

                VelocityCommandTypeEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                VelocityCommandTypeEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                VelocityCommandTypeEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                VelocityCommandTypeEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                VelocityCommandTypeEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &VelocityCommandTypeEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo VelocityCommandTypeEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo VelocityCommandTypeEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &VelocityCommandTypeEnumType_g_sampleAccessInfo;
                }

                VelocityCommandTypeEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                VelocityCommandTypeEnumType_g_sampleAccessInfo.memberAccessInfos = 
                VelocityCommandTypeEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        VelocityCommandTypeEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        VelocityCommandTypeEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                VelocityCommandTypeEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                VelocityCommandTypeEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType >;

                VelocityCommandTypeEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &VelocityCommandTypeEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin VelocityCommandTypeEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &VelocityCommandTypeEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::VelocityCommandTypeEnumType::VelocityCommandTypeEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::VideoFormatEnumType::VideoFormatEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::VideoFormatEnumType::VideoFormatEnumType>::value = UMAA::Common::MaritimeEnumeration::VideoFormatEnumType::VideoFormatEnumType::NTSCJ;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::VideoFormatEnumType::VideoFormatEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member VideoFormatEnumType_g_tc_members[6]=
                {

                    {
                        (char *)"NTSCJ",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VideoFormatEnumType::VideoFormatEnumType::NTSCJ), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"NTSCM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VideoFormatEnumType::VideoFormatEnumType::NTSCM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PALM",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VideoFormatEnumType::VideoFormatEnumType::PALM), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"PALN",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VideoFormatEnumType::VideoFormatEnumType::PALN), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SECAMBG",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VideoFormatEnumType::VideoFormatEnumType::SECAMBG), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SECAML",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VideoFormatEnumType::VideoFormatEnumType::SECAML), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode VideoFormatEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::VideoFormatEnumType::VideoFormatEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        6, /* Number of members */
                        VideoFormatEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for VideoFormatEnumType*/

                if (is_initialized) {
                    return &VideoFormatEnumType_g_tc;
                }

                VideoFormatEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                VideoFormatEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                VideoFormatEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                VideoFormatEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                VideoFormatEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &VideoFormatEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo VideoFormatEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo VideoFormatEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &VideoFormatEnumType_g_sampleAccessInfo;
                }

                VideoFormatEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                VideoFormatEnumType_g_sampleAccessInfo.memberAccessInfos = 
                VideoFormatEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::VideoFormatEnumType::VideoFormatEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        VideoFormatEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        VideoFormatEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                VideoFormatEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                VideoFormatEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::VideoFormatEnumType::VideoFormatEnumType >;

                VideoFormatEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &VideoFormatEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin VideoFormatEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &VideoFormatEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::VideoFormatEnumType::VideoFormatEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::VideoFormatEnumType::VideoFormatEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType>::value = UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::AID_TO_NAVIGATION_CHANNEL_MARKER;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member VisualClassificationEnumType_g_tc_members[25]=
                {

                    {
                        (char *)"AID_TO_NAVIGATION_CHANNEL_MARKER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::AID_TO_NAVIGATION_CHANNEL_MARKER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MEDIUM_VESSEL_FISHING",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::MEDIUM_VESSEL_FISHING), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"AID_TO_NAVIGATION_GENERAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::AID_TO_NAVIGATION_GENERAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SMALL_VESSEL_JET_SKI",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::SMALL_VESSEL_JET_SKI), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"AID_TO_NAVIGATION_LARGE_BUOY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::AID_TO_NAVIGATION_LARGE_BUOY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LARGE_VESSEL_CARGO",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::LARGE_VESSEL_CARGO), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LARGE_GENERAL_OBSTACLE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::LARGE_GENERAL_OBSTACLE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LARGE_VESSEL_GENERAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::LARGE_VESSEL_GENERAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LARGE_VESSEL_MILITARY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::LARGE_VESSEL_MILITARY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LARGE_VESSEL_PASSENGER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::LARGE_VESSEL_PASSENGER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LARGE_VESSEL_OTHER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::LARGE_VESSEL_OTHER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"AID_TO_NAVIGATION_LIGHTHOUSE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::AID_TO_NAVIGATION_LIGHTHOUSE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MEDIUM_VESSEL_GENERAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::MEDIUM_VESSEL_GENERAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MEDIUM_VESSEL_MILITARY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::MEDIUM_VESSEL_MILITARY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MEDIUM_VESSEL_OTHER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::MEDIUM_VESSEL_OTHER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SMALL_VESSEL_POWER_BOAT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::SMALL_VESSEL_POWER_BOAT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SAILBOAT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::SAILBOAT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"AID_TO_NAVIGATION_SMALL_BUOY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::AID_TO_NAVIGATION_SMALL_BUOY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SMALL_GENERAL_OBSTACLE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::SMALL_GENERAL_OBSTACLE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SMALL_VESSEL_GENERAL",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::SMALL_VESSEL_GENERAL), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SMALL_VESSEL_MILITARY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::SMALL_VESSEL_MILITARY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SMALL_VESSEL_OTHER",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::SMALL_VESSEL_OTHER), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MEDIUM_VESSEL_TUG",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::MEDIUM_VESSEL_TUG), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MEDIUM_VESSEL_TUG_IN_TOW",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::MEDIUM_VESSEL_TUG_IN_TOW), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MEDIUM_VESSEL_YACHT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType::MEDIUM_VESSEL_YACHT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode VisualClassificationEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        25, /* Number of members */
                        VisualClassificationEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for VisualClassificationEnumType*/

                if (is_initialized) {
                    return &VisualClassificationEnumType_g_tc;
                }

                VisualClassificationEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                VisualClassificationEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                VisualClassificationEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                VisualClassificationEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                VisualClassificationEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &VisualClassificationEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo VisualClassificationEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo VisualClassificationEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &VisualClassificationEnumType_g_sampleAccessInfo;
                }

                VisualClassificationEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                VisualClassificationEnumType_g_sampleAccessInfo.memberAccessInfos = 
                VisualClassificationEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        VisualClassificationEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        VisualClassificationEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                VisualClassificationEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                VisualClassificationEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType >;

                VisualClassificationEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &VisualClassificationEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin VisualClassificationEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &VisualClassificationEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::VisualClassificationEnumType::VisualClassificationEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::WaterTurnDirectionEnumType::WaterTurnDirectionEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::WaterTurnDirectionEnumType::WaterTurnDirectionEnumType>::value = UMAA::Common::MaritimeEnumeration::WaterTurnDirectionEnumType::WaterTurnDirectionEnumType::NO_VALID_TURN_DIRECTION;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::WaterTurnDirectionEnumType::WaterTurnDirectionEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member WaterTurnDirectionEnumType_g_tc_members[6]=
                {

                    {
                        (char *)"NO_VALID_TURN_DIRECTION",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WaterTurnDirectionEnumType::WaterTurnDirectionEnumType::NO_VALID_TURN_DIRECTION), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"LEFT_TURN",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WaterTurnDirectionEnumType::WaterTurnDirectionEnumType::LEFT_TURN), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"RIGHT_TURN",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WaterTurnDirectionEnumType::WaterTurnDirectionEnumType::RIGHT_TURN), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"VEHICLE_SPECIFIC",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WaterTurnDirectionEnumType::WaterTurnDirectionEnumType::VEHICLE_SPECIFIC), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INTO_THE_CURRENT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WaterTurnDirectionEnumType::WaterTurnDirectionEnumType::INTO_THE_CURRENT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"INTO_THE_WIND",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WaterTurnDirectionEnumType::WaterTurnDirectionEnumType::INTO_THE_WIND), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode WaterTurnDirectionEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::WaterTurnDirectionEnumType::WaterTurnDirectionEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        6, /* Number of members */
                        WaterTurnDirectionEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for WaterTurnDirectionEnumType*/

                if (is_initialized) {
                    return &WaterTurnDirectionEnumType_g_tc;
                }

                WaterTurnDirectionEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                WaterTurnDirectionEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                WaterTurnDirectionEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                WaterTurnDirectionEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                WaterTurnDirectionEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &WaterTurnDirectionEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo WaterTurnDirectionEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo WaterTurnDirectionEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &WaterTurnDirectionEnumType_g_sampleAccessInfo;
                }

                WaterTurnDirectionEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                WaterTurnDirectionEnumType_g_sampleAccessInfo.memberAccessInfos = 
                WaterTurnDirectionEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::WaterTurnDirectionEnumType::WaterTurnDirectionEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        WaterTurnDirectionEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        WaterTurnDirectionEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                WaterTurnDirectionEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                WaterTurnDirectionEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::WaterTurnDirectionEnumType::WaterTurnDirectionEnumType >;

                WaterTurnDirectionEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &WaterTurnDirectionEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin WaterTurnDirectionEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &WaterTurnDirectionEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::WaterTurnDirectionEnumType::WaterTurnDirectionEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::WaterTurnDirectionEnumType::WaterTurnDirectionEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType>::value = UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType::AUTO_DEFAULT;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member WhiteBalanceEnumType_g_tc_members[7]=
                {

                    {
                        (char *)"AUTO_DEFAULT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType::AUTO_DEFAULT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"CLOUDY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType::CLOUDY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DAYLIGHT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType::DAYLIGHT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FLASH",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType::FLASH), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"FLUORESCENT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType::FLUORESCENT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"SHADE",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType::SHADE), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"TUNGSTEN",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType::TUNGSTEN), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode WhiteBalanceEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        7, /* Number of members */
                        WhiteBalanceEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for WhiteBalanceEnumType*/

                if (is_initialized) {
                    return &WhiteBalanceEnumType_g_tc;
                }

                WhiteBalanceEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                WhiteBalanceEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                WhiteBalanceEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                WhiteBalanceEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                WhiteBalanceEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &WhiteBalanceEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo WhiteBalanceEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo WhiteBalanceEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &WhiteBalanceEnumType_g_sampleAccessInfo;
                }

                WhiteBalanceEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                WhiteBalanceEnumType_g_sampleAccessInfo.memberAccessInfos = 
                WhiteBalanceEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        WhiteBalanceEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        WhiteBalanceEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                WhiteBalanceEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                WhiteBalanceEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType >;

                WhiteBalanceEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &WhiteBalanceEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin WhiteBalanceEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &WhiteBalanceEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::WhiteBalanceEnumType::WhiteBalanceEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::ZoneKindEnumType::ZoneKindEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::ZoneKindEnumType::ZoneKindEnumType>::value = UMAA::Common::MaritimeEnumeration::ZoneKindEnumType::ZoneKindEnumType::KEEP_IN;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::ZoneKindEnumType::ZoneKindEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member ZoneKindEnumType_g_tc_members[2]=
                {

                    {
                        (char *)"KEEP_IN",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ZoneKindEnumType::ZoneKindEnumType::KEEP_IN), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"KEEP_OUT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ZoneKindEnumType::ZoneKindEnumType::KEEP_OUT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode ZoneKindEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::ZoneKindEnumType::ZoneKindEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        2, /* Number of members */
                        ZoneKindEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for ZoneKindEnumType*/

                if (is_initialized) {
                    return &ZoneKindEnumType_g_tc;
                }

                ZoneKindEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                ZoneKindEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                ZoneKindEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                ZoneKindEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                ZoneKindEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &ZoneKindEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo ZoneKindEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo ZoneKindEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &ZoneKindEnumType_g_sampleAccessInfo;
                }

                ZoneKindEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                ZoneKindEnumType_g_sampleAccessInfo.memberAccessInfos = 
                ZoneKindEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::ZoneKindEnumType::ZoneKindEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        ZoneKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        ZoneKindEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                ZoneKindEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                ZoneKindEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::ZoneKindEnumType::ZoneKindEnumType >;

                ZoneKindEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &ZoneKindEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin ZoneKindEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &ZoneKindEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::ZoneKindEnumType::ZoneKindEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::ZoneKindEnumType::ZoneKindEnumType >::get())));
        }

        #ifndef NDDS_STANDALONE_TYPE
        const UMAA::Common::MaritimeEnumeration::ZoomModeEnumType::ZoomModeEnumType default_enumerator<UMAA::Common::MaritimeEnumeration::ZoomModeEnumType::ZoomModeEnumType>::value = UMAA::Common::MaritimeEnumeration::ZoomModeEnumType::ZoomModeEnumType::ANALOG_ONLY;
        template<>
        struct native_type_code< UMAA::Common::MaritimeEnumeration::ZoomModeEnumType::ZoomModeEnumType > {
            static DDS_TypeCode * get()
            {
                using namespace ::rti::topic::interpreter;

                static RTIBool is_initialized = RTI_FALSE;

                static DDS_TypeCode_Member ZoomModeEnumType_g_tc_members[4]=
                {

                    {
                        (char *)"ANALOG_ONLY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ZoomModeEnumType::ZoomModeEnumType::ANALOG_ONLY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"DIGITAL_ONLY",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ZoomModeEnumType::ZoomModeEnumType::DIGITAL_ONLY), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"OFF",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ZoomModeEnumType::ZoomModeEnumType::OFF), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }, 
                    {
                        (char *)"MIXED_DEFAULT",/* Member name */
                        {
                            0, /* Ignored */
                            DDS_BOOLEAN_FALSE,/* Is a pointer? */
                            -1, /* Bitfield bits */
                            NULL/* Member type code is assigned later */
                        },
                        static_cast<int>(UMAA::Common::MaritimeEnumeration::ZoomModeEnumType::ZoomModeEnumType::MIXED_DEFAULT), 
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
                        DDS_PRIVATE_MEMBER,/* Member visibility */ 

                        1,
                        NULL, /* Ignored */
                        RTICdrTypeCodeAnnotations_INITIALIZER
                    }
                };

                static DDS_TypeCode ZoomModeEnumType_g_tc =
                {{
                        DDS_TK_ENUM, /* Kind */
                        DDS_BOOLEAN_FALSE, /* Ignored */
                        -1, /*Ignored*/
                        (char *)"UMAA::Common::MaritimeEnumeration::ZoomModeEnumType::ZoomModeEnumType", /* Name */
                        NULL,     /* Base class type code is assigned later */      
                        0, /* Ignored */
                        0, /* Ignored */
                        NULL, /* Ignored */
                        4, /* Number of members */
                        ZoomModeEnumType_g_tc_members, /* Members */
                        DDS_VM_NONE, /* Type Modifier */
                        RTICdrTypeCodeAnnotations_INITIALIZER,
                        DDS_BOOLEAN_TRUE, /* _isCopyable */
                        NULL, /* _sampleAccessInfo: assigned later */
                        NULL /* _typePlugin: assigned later */
                    }}; /* Type code for ZoomModeEnumType*/

                if (is_initialized) {
                    return &ZoomModeEnumType_g_tc;
                }

                ZoomModeEnumType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

                /* Initialize the values for annotations. */
                ZoomModeEnumType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
                ZoomModeEnumType_g_tc._data._annotations._defaultValue._u.long_value = 0;

                ZoomModeEnumType_g_tc._data._sampleAccessInfo = sample_access_info();
                ZoomModeEnumType_g_tc._data._typePlugin = type_plugin_info();    

                is_initialized = RTI_TRUE;

                return &ZoomModeEnumType_g_tc;
            }

            static RTIXCdrSampleAccessInfo * sample_access_info()
            {
                static RTIBool is_initialized = RTI_FALSE;

                static RTIXCdrMemberAccessInfo ZoomModeEnumType_g_memberAccessInfos[1] =
                {RTIXCdrMemberAccessInfo_INITIALIZER};

                static RTIXCdrSampleAccessInfo ZoomModeEnumType_g_sampleAccessInfo = 
                RTIXCdrSampleAccessInfo_INITIALIZER;

                if (is_initialized) {
                    return (RTIXCdrSampleAccessInfo*) &ZoomModeEnumType_g_sampleAccessInfo;
                }

                ZoomModeEnumType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

                ZoomModeEnumType_g_sampleAccessInfo.memberAccessInfos = 
                ZoomModeEnumType_g_memberAccessInfos;

                {
                    size_t candidateTypeSize = sizeof(UMAA::Common::MaritimeEnumeration::ZoomModeEnumType::ZoomModeEnumType);

                    if (candidateTypeSize > RTIXCdrLong_MAX) {
                        ZoomModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        RTIXCdrLong_MAX;
                    } else {
                        ZoomModeEnumType_g_sampleAccessInfo.typeSize[0] =
                        (RTIXCdrUnsignedLong) candidateTypeSize;
                    }
                }

                ZoomModeEnumType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
                RTI_XCDR_TRUE;

                ZoomModeEnumType_g_sampleAccessInfo.getMemberValuePointerFcn = 
                interpreter::get_aggregation_value_pointer< UMAA::Common::MaritimeEnumeration::ZoomModeEnumType::ZoomModeEnumType >;

                ZoomModeEnumType_g_sampleAccessInfo.languageBinding = 
                RTI_XCDR_TYPE_BINDING_CPP_11_STL ;

                is_initialized = RTI_TRUE;
                return (RTIXCdrSampleAccessInfo*) &ZoomModeEnumType_g_sampleAccessInfo;
            }

            static RTIXCdrTypePlugin * type_plugin_info()
            {
                static RTIXCdrTypePlugin ZoomModeEnumType_g_typePlugin = 
                {
                    NULL, /* serialize */
                    NULL, /* serialize_key */
                    NULL, /* deserialize_sample */
                    NULL, /* deserialize_key_sample */
                    NULL, /* skip */
                    NULL, /* get_serialized_sample_size */
                    NULL, /* get_serialized_sample_max_size_ex */
                    NULL, /* get_serialized_key_max_size_ex */
                    NULL, /* get_serialized_sample_min_size */
                    NULL, /* serialized_sample_to_key */
                    NULL,
                    NULL,
                    NULL,
                    NULL
                };

                return &ZoomModeEnumType_g_typePlugin;
            }
        }; // native_type_code
        #endif

        const ::dds::core::xtypes::EnumType& dynamic_type< UMAA::Common::MaritimeEnumeration::ZoomModeEnumType::ZoomModeEnumType >::get()
        {
            return static_cast<const ::dds::core::xtypes::EnumType&>(
                ::rti::core::native_conversions::cast_from_native< ::dds::core::xtypes::DynamicType >(
                    *(native_type_code< UMAA::Common::MaritimeEnumeration::ZoomModeEnumType::ZoomModeEnumType >::get())));
        }

    }
}

namespace dds { 
    namespace topic {
        #undef ERROR
        #undef VARIABLE_PITCH
        #undef DELETE
        #undef PLATFORM
    }
}  

